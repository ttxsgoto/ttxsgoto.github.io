<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ttxsgoto&#39; Blog</title>
  <subtitle>好好学习 努力工作 享受生活</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ttxsgoto.github.io/"/>
  <updated>2019-01-07T03:37:29.000Z</updated>
  <id>https://ttxsgoto.github.io/</id>
  
  <author>
    <name>ttxsgoto</name>
    <email>zhongqiang2014@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Jenkins+Gitlab+Harbor构建持续集成</title>
    <link href="https://ttxsgoto.github.io/2019/01/04/yw-jenkins-ci/"/>
    <id>https://ttxsgoto.github.io/2019/01/04/yw-jenkins-ci/</id>
    <published>2019-01-04T06:41:44.000Z</published>
    <updated>2019-01-07T03:37:29.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>最近研究了一下公司现有的发布流程，<br>开发在开发完成代码后， 不需要关注代码发布流程， 使用Jenkins工具，自动发布代码到测试环境，然后进行测试，提高研发工作效率和减少运维人员重复工作</p>
<h4 id="组件说明"><a href="#组件说明" class="headerlink" title="组件说明"></a>组件说明</h4><h5 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h5><p>jenkins是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能<br>特点：</p>
<ul>
<li>分布式构建</li>
<li>大量三方插件</li>
<li>变更支持</li>
<li>消息通知</li>
</ul>
<h5 id="Gitlab"><a href="#Gitlab" class="headerlink" title="Gitlab"></a>Gitlab</h5><p>Gitlab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务<br>特点：</p>
<ul>
<li>代码仓库管理</li>
<li>多人协作</li>
</ul>
<h5 id="Harbor"><a href="#Harbor" class="headerlink" title="Harbor"></a>Harbor</h5><p>Harbor 是一个用于存储和分发 Docker 镜像的企业级 Registry 服务器<br>特点：</p>
<ul>
<li>基于角色的访问控制</li>
<li>镜像复制</li>
<li>鉴权认证管理</li>
<li>用户管理，访问控制和活动审计</li>
<li>RESTful API</li>
</ul>
<h4 id="实现说明"><a href="#实现说明" class="headerlink" title="实现说明"></a>实现说明</h4><p>步骤：</p>
<ol>
<li>通过Jenkins 生成的secret token来关联gitlab Webhooks设置url 和token，当代码有更新时，自动触发构建</li>
<li>将代码拉取到Jenkins运行节点中，通过基础镜像加dockerfile文件构建应用镜像，然后上传到Harbor服务器中</li>
<li>在测试服务器中拉取对应的镜像，然后运行起来</li>
<li>构建完成没有错误，发邮件通知相关人员</li>
</ol>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol>
<li>Jenkins系统设置中需要配置gitlab服务器地址和对应的gitlab api token用于Jenkins和gitlab交互通信</li>
<li>Jenkins任务构建可以指定在固定节点上构建， 构建节点和应用服务器之间必须有登录权限</li>
<li>Harbor镜像管理，需要有鉴权和认证设置</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;p&gt;最近研究了一下公司现有的发布流程，&lt;br&gt;开发在开发完成代码后， 不需要关注代码发布流程， 使用Jenkins工具，自动发布代码到测试环境，
    
    </summary>
    
      <category term="运维" scheme="https://ttxsgoto.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Jenkins" scheme="https://ttxsgoto.github.io/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>Count计数变慢</title>
    <link href="https://ttxsgoto.github.io/2018/12/28/yw-mysql-count/"/>
    <id>https://ttxsgoto.github.io/2018/12/28/yw-mysql-count/</id>
    <published>2018-12-28T14:48:50.000Z</published>
    <updated>2018-12-28T01:51:36.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="count-实现方式"><a href="#count-实现方式" class="headerlink" title="count(*) 实现方式"></a>count(*) 实现方式</h4><p>不同的引擎，实现方式不同</p>
<ul>
<li>Myisam把一个表的总行存在磁盘上，执行时直接返回这个数</li>
<li>Innodb，需要把数据一行行的从引擎中读出来，然后累积计数，遍历全表</li>
</ul>
<h4 id="不同的count用法"><a href="#不同的count用法" class="headerlink" title="不同的count用法"></a>不同的count用法</h4><p>count()为聚合函数，对于返回的结果集，一行行判断，如果count函数的参数不为null，累计值加1，最终返回累计值</p>
<ul>
<li>count(*)</li>
<li>count(id)</li>
<li>count(字段)</li>
<li>count(1)</li>
</ul>
<p>这里count(*),count(id),count(1)返回满足条件的结果集的总行数，而count(字段)返回满足条件不为null的总数<br>性能比较原则：</p>
<ol>
<li>server层要做什么就给什么</li>
<li>innodb只给必要的值</li>
</ol>
<h4 id="效率排序"><a href="#效率排序" class="headerlink" title="效率排序"></a>效率排序</h4><p>count(字段)&lt; count(id)&lt;count(1)=count(*)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;count-实现方式&quot;&gt;&lt;a href=&quot;#count-实现方式&quot; class=&quot;headerlink&quot; title=&quot;count(*) 实现方式&quot;&gt;&lt;/a&gt;count(*) 实现方式&lt;/h4&gt;&lt;p&gt;不同的引擎，实现方式不同&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Myisam
    
    </summary>
    
      <category term="Mysql" scheme="https://ttxsgoto.github.io/categories/Mysql/"/>
    
    
      <category term="count" scheme="https://ttxsgoto.github.io/tags/count/"/>
    
  </entry>
  
  <entry>
    <title>Order by工作原理</title>
    <link href="https://ttxsgoto.github.io/2018/12/28/yw-mysql-order-by/"/>
    <id>https://ttxsgoto.github.io/2018/12/28/yw-mysql-order-by/</id>
    <published>2018-12-28T14:46:51.000Z</published>
    <updated>2018-12-28T01:48:25.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h4><p>mysql会给每个线程分配一块内存用于排序，称为sort_buffer</p>
<p>sort_buffer_size 是mysql为排序开辟的内存大小(sort_buffer)大小，如果要排序的数据量小于sort_buffer_size，排序在内存中完成，如果排序数据量太大，大于该值，则需要用磁盘临时文件辅助排序</p>
<h4 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序"></a>rowid排序</h4><p>全字段排序只对原表数据读取一次，剩下的都在sort_buffer和临时文件中进行，如果查询返回的字段很多，那么sort_buffer里面存放的字段数太多，内存里放下的数据行数就很少，需要分成很多个临时文件，排序的性能会受影响，这时需要使用rowid排序</p>
<p>max_length_for_sort_data 字段用来控制排序的行数据的长度的参数，如果单行的长度超过这个值，mysql会换一种算法，即将查询的列和主键id放入sort_buffer中</p>
<p>这种算法需要多访问一次表的主键索引</p>
<p>如果内存大，mysql就会多利用内存，尽量减少磁盘访问</p>
<p><strong>写入有序数据，通过索引本身就是写入数据就是有序的，那么order by 就不需要排序了，直接就是对应的数据</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;全字段排序&quot;&gt;&lt;a href=&quot;#全字段排序&quot; class=&quot;headerlink&quot; title=&quot;全字段排序&quot;&gt;&lt;/a&gt;全字段排序&lt;/h4&gt;&lt;p&gt;mysql会给每个线程分配一块内存用于排序，称为sort_buffer&lt;/p&gt;
&lt;p&gt;sort_buffer_siz
    
    </summary>
    
      <category term="Mysql" scheme="https://ttxsgoto.github.io/categories/Mysql/"/>
    
    
      <category term="排序" scheme="https://ttxsgoto.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>字符串加索引</title>
    <link href="https://ttxsgoto.github.io/2018/12/28/yw-mysql-addindex-to-string/"/>
    <id>https://ttxsgoto.github.io/2018/12/28/yw-mysql-addindex-to-string/</id>
    <published>2018-12-28T12:41:50.000Z</published>
    <updated>2018-12-28T01:45:39.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>前缀字符长度索引，所占空间更小，同时会增加额外的记录扫描次数</p>
<p>在建立索引时需要关注的是区分度，区分度越高越好</p>
<p>查看对应索引的区分度方法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">select count(distinct a) <span class="keyword">as</span> L <span class="keyword">from</span> user;</div><div class="line">select count(*) <span class="keyword">as</span> total <span class="keyword">from</span> user;</div><div class="line"> </div><div class="line">select count(distinct left(a, <span class="number">4</span>) <span class="keyword">as</span> L4,</div><div class="line">       count(distinct left(a, <span class="number">5</span>) <span class="keyword">as</span> L5,</div><div class="line"><span class="keyword">from</span> user</div></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：使用前缀索引就用不上覆盖索引查询对查询性能的优化，这是在选择是否使用前缀索引时需要考虑的因素</p>
<h4 id="倒序存储"><a href="#倒序存储" class="headerlink" title="倒序存储"></a>倒序存储</h4><p>对前面n位数都是重复的字段，可以使用倒序存储，将存储的内容倒序存储<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select field <span class="keyword">from</span> t where word=reverse(<span class="string">'input_string'</span>);</div></pre></td></tr></table></figure></p>
<h4 id="使用hash字段"><a href="#使用hash字段" class="headerlink" title="使用hash字段"></a>使用hash字段</h4><p>在表中再创建一个整数字段，来保存字段的校验码，同时在这个字段创建索引<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alter table t add word_crc int unsigned, <span class="keyword">and</span> index(word_crc);</div></pre></td></tr></table></figure></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>直接创建完整索引，这样可能会占用大量的空间</li>
<li>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引</li>
<li>倒序存储，在创建前缀索引，用于绕过字符串本身前缀区分度不高的问题</li>
<li>创建hash字段索引，查询性能稳定，有额外的存储和计算消耗，同时不支持范围扫描</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前缀索引&quot;&gt;&lt;a href=&quot;#前缀索引&quot; class=&quot;headerlink&quot; title=&quot;前缀索引&quot;&gt;&lt;/a&gt;前缀索引&lt;/h4&gt;&lt;p&gt;前缀字符长度索引，所占空间更小，同时会增加额外的记录扫描次数&lt;/p&gt;
&lt;p&gt;在建立索引时需要关注的是区分度，区分度越高越好&lt;
    
    </summary>
    
      <category term="Mysql" scheme="https://ttxsgoto.github.io/categories/Mysql/"/>
    
    
      <category term="Index" scheme="https://ttxsgoto.github.io/tags/Index/"/>
    
  </entry>
  
  <entry>
    <title>全局锁、表级锁和行锁</title>
    <link href="https://ttxsgoto.github.io/2018/12/27/yw-mysql-lock/"/>
    <id>https://ttxsgoto.github.io/2018/12/27/yw-mysql-lock/</id>
    <published>2018-12-27T14:44:05.000Z</published>
    <updated>2018-12-27T09:50:15.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h4><ul>
<li>全局锁</li>
<li>表级锁</li>
<li>行锁</li>
</ul>
<h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><p>全局锁就是对整个数据库实例加锁<br>命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flush tables with read lock</div></pre></td></tr></table></figure></p>
<p>使用该命令后其他线程的执行语句都会被阻塞：数据更新语句(数据的增删改)和数据定义语句(建表和修改表结构等)和更新事务的提交语句</p>
<p><strong>应用</strong>：全库逻辑备份</p>
<ul>
<li>innodb引擎， mysqldump 使用参数-single-transaction，导数据时会启动一个事务，来确保一致性视图</li>
<li>myisam引擎，不支持事务，需要使用FTWRL命令</li>
</ul>
<h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><h5 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h5><p>语句:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lock tables xxx read/write;</div><div class="line">unlock tables;</div></pre></td></tr></table></figure></p>
<p>表锁是最常用的处理并发的方式，而对于innodb这种行锁的引擎，一般不会使用lock tables命令来控制并发，因为锁住整个表的影响太大</p>
<h5 id="元数据锁-meta-data-lock-MDL"><a href="#元数据锁-meta-data-lock-MDL" class="headerlink" title="元数据锁(meta data lock, MDL)"></a>元数据锁(meta data lock, MDL)</h5><p>MDL不需要显示使用，在访问一个表时会自动加上，MDL的作用，保证读写的正确性</p>
<ul>
<li>在对一个表做增删改查操作，加MDL读锁，当要对表做结构变更操作，加MDL写锁</li>
<li>读锁之间不互斥，可以有多个线程对一张表增删改查</li>
<li>读写锁之间，写锁之间互斥，用来保证变更表结构操作的安全性,如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完成后才能开始执行</li>
</ul>
<h5 id="安全给小表加字段"><a href="#安全给小表加字段" class="headerlink" title="安全给小表加字段"></a>安全给小表加字段</h5><ol>
<li>需要解决长事务，事务不提交，就会一直占用MDL锁，mysql中的information_schema库中INNODB_TRX表中记录着当前执行中的事务</li>
<li>变更热点表，在alter table语句里面设置等待时间，如果在等待时间没有拿到也不会阻塞 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alter table xxx nowait add column ...</div><div class="line">alter table yyy wait n add column ...</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>行锁是针对数据表中的行记录的锁</p>
<p>mysql行锁是在引擎层自己实现的，并不是所有引擎都支持行锁，如myisam引擎不支持行锁，只能使用表锁，任何时刻只能有一个更新在执行，影响业务并发度</p>
<h5 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h5><p>在innodb事务中，行锁是在需要的时候才加上，但并不是不需要了立刻释放，而是要等到事务结束时才释放</p>
<p><strong>如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放</strong></p>
<h5 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h5><p>死锁：当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态</p>
<p>出现死锁，解决策略：</p>
<ul>
<li>直接进入等待，直到超时，超时时间可以通过参数<code>innodb_lock_wait_timeout</code>来设置，默认值为50s</li>
<li>发起死锁检测，发现死锁后，主动回滚死锁链条中的某个事物，让其他事物得以继续执行，通过参数<code>innodb_deadlock_detect</code>设置为on，来开启死锁检测</li>
</ul>
<p>如果所有事务都要更新同一行，这时死锁检测将消耗大量cpu资源，因此出现cpu利用率很高，但每秒执行不了多少事务</p>
<p>解决方案：</p>
<ul>
<li>控制并发，在数据库服务端控制并发，需要修改mysql源码，要求高</li>
<li>业务上，将更新一行改为逻辑上的多行来减少锁冲突</li>
<li>减少死锁的主要方向，控制访问相同资源的并发事务量</li>
</ul>
<p>innodb行级锁是通过锁索引记录实现的，如果更新的列没有建索引会锁住整个表的</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;锁分类&quot;&gt;&lt;a href=&quot;#锁分类&quot; class=&quot;headerlink&quot; title=&quot;锁分类&quot;&gt;&lt;/a&gt;锁分类&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;全局锁&lt;/li&gt;
&lt;li&gt;表级锁&lt;/li&gt;
&lt;li&gt;行锁&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;全局锁&quot;&gt;&lt;a href
    
    </summary>
    
      <category term="Mysql" scheme="https://ttxsgoto.github.io/categories/Mysql/"/>
    
    
      <category term="Lock" scheme="https://ttxsgoto.github.io/tags/Lock/"/>
    
  </entry>
  
  <entry>
    <title>事务隔离</title>
    <link href="https://ttxsgoto.github.io/2018/12/26/yw-mysql-transaction/"/>
    <id>https://ttxsgoto.github.io/2018/12/26/yw-mysql-transaction/</id>
    <published>2018-12-26T13:42:58.000Z</published>
    <updated>2018-12-27T09:50:08.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>事务是为了保证一组数据库操作，要么全部执行成功，要么全部执行不成功，InnoDB支持，Myisam不支持</p>
<h4 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h4><ul>
<li>原子性</li>
<li>一致性</li>
<li>隔离性</li>
<li>持久性</li>
</ul>
<h4 id="多事务同时执行引起的问题"><a href="#多事务同时执行引起的问题" class="headerlink" title="多事务同时执行引起的问题"></a>多事务同时执行引起的问题</h4><ul>
<li>脏读</li>
<li>不可重复读</li>
<li>幻读</li>
</ul>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><ul>
<li>读未提交(read uncommitted) 一个事务还没提交时，它做的变更就能被别的事务看到</li>
<li>读提交(read committed) 一个事务提交之后，它做的变更才会被其他事务看到</li>
<li>可重复读(repeatable read) 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的</li>
<li>串行化(serializable) “写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突时，后访问的事务必须等前一个事务执行完成后，才能继续执行</li>
</ul>
<h4 id="配置事务方法"><a href="#配置事务方法" class="headerlink" title="配置事务方法"></a>配置事务方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">启动参数transaction-isolation</div></pre></td></tr></table></figure>
<h4 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h4><p>每条记录在更新的时候都会同时记录一条回滚操作。通过回滚操作，都可以得到前一个状态的值</p>
<p>同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。</p>
<p>回滚日志在不需要的时候删除，当系统里没有比这个回滚日志更早的read-view时候，系统自动删除</p>
<h4 id="尽量不要使用长事务"><a href="#尽量不要使用长事务" class="headerlink" title="尽量不要使用长事务"></a>尽量不要使用长事务</h4><p>长事务意味着系统里面会存在很老的事务视图，在事务提交之前，回滚日志必须保留，这就会导致大量占用存储空间</p>
<h4 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h4><ul>
<li><p>显示启动事务</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">begin transaction</div><div class="line">do something</div><div class="line">commit / rollback</div></pre></td></tr></table></figure>
</li>
<li><p>set autocommit=0，将这个线程的自动提交关掉，只要你执行一个查询语句，事务就启动了，接下来的查询都在事务中，如果是长连接，将导致意外的长事务，这样直到你主动执行commit或者rollback语句或者断开连接才释放，可以通过set autocommit=1来显式方式来启动事务</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">begin tracsaction; #  不是一个事务的起点，在执行到它之后的第一个操作InnoDB语句，事务才真正启动</div><div class="line">start transaction with consistent snapshot; # 马上启动一个事务</div><div class="line"> </div><div class="line">commit;     # 提交事务</div><div class="line">autocommit=1;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="事务隔离-or-不隔离"><a href="#事务隔离-or-不隔离" class="headerlink" title="事务隔离 or 不隔离"></a>事务隔离 or 不隔离</h4><p>如果是可重复读隔离级别，事务启动时会创建一个视图read-view，之后事务执行期间，即使有其他事务修改了数据，该事务看到的仍然跟启动时看到的一样，也就是在可重复读隔离级别下执行事务，不受外界影响<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">start transaction with consistent snapshot;    # 执行该命令后马上启动一个事务</div></pre></td></tr></table></figure></p>
<p>Mysql中的两个“视图”：</p>
<ul>
<li>一个view，用于查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果</li>
<li>InnoDB在实现MCVV时用到的一致性读视图，即consistent read view，用于支持RC(Read Committed，读提交)和RR(Repeatable Read，可重复读)隔离级别的实现，作用在事务执行期间用来定义”我能看到什么数据”</li>
</ul>
<h4 id="“快照”在MVCC里是怎么工作的"><a href="#“快照”在MVCC里是怎么工作的" class="headerlink" title="“快照”在MVCC里是怎么工作的"></a>“快照”在MVCC里是怎么工作的</h4><p>在可重复读隔离级别下，事务在启动的时候就拍下快照，这个快照是基于整库</p>
<p>Innodb里面每个事务有一个唯一的事务ID，叫作transaction id，它是在事务开始的时候向Innodb的事务系统申请的，是按申请顺序严格递增的</p>
<p>每行数据也都都是有多个版本的，每次事务更新数据时，都会生成一个新的数据版本，而且把transaction id赋值给这个数据版本的事务id，记为row trx_id; 同时，旧的数据版本要保留，并且在新的数据版本中能够有信息可以直接拿到它</p>
<p>数据表中一行记录，其实可能有多个版本(row)，每个版本有自己的rowtrx_id</p>
<p>InnoDB利用了“所有数据都有多个版本”的特性，实现了“秒级创建快照的能力”</p>
<p>更新数据都要先读后写，而这个读，只能读当前的值，称之为”当前读”；当前读总是读取已经提交完成的最新版本</p>
<ul>
<li>对于可重复读，查询只承认在事务启动前就已经提交完成的数据</li>
<li>对于读提交，查询只承认在语句启动前就已经提交完成的数据</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h4&gt;&lt;p&gt;事务是为了保证一组数据库操作，要么全部执行成功，要么全部执行不成功，InnoDB支持，Myisam不支持&lt;/p&gt;
&lt;h4 id=&quot;事务的特性
    
    </summary>
    
      <category term="Mysql" scheme="https://ttxsgoto.github.io/categories/Mysql/"/>
    
    
      <category term="Transaction" scheme="https://ttxsgoto.github.io/tags/Transaction/"/>
    
  </entry>
  
  <entry>
    <title>Redo log 和 Binlog</title>
    <link href="https://ttxsgoto.github.io/2018/12/25/yw-mysql-redo-binlog/"/>
    <id>https://ttxsgoto.github.io/2018/12/25/yw-mysql-redo-binlog/</id>
    <published>2018-12-25T11:43:38.000Z</published>
    <updated>2018-12-25T11:48:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>WAL(Write-Ahead-Logging),先写日志，再写磁盘</p>
<ul>
<li>redo log(重做日志)<ul>
<li>存储引擎层面</li>
<li>存储容量大小固定，循环写</li>
<li>checkpoint 当前要擦除的位置，擦除记录前需要将数据更新到数据文件中</li>
<li>write-pos 当前写入记录的位置</li>
<li>功能：保证InnoDB即使数据库发生异常重启，之前提交的记录也不会丢失(crash-safe)</li>
<li>插件式，innodb引擎特有</li>
<li>物流日志-记录在某个数据页上做了什么修改</li>
</ul>
</li>
<li>binlog(归档日志)<ul>
<li>Server层面</li>
<li>逻辑日志，记录的是这个语句的原始逻辑，sql语句是什么样子的</li>
</ul>
</li>
</ul>
<p>执行器和引擎执行update操作流程：</p>
<ol>
<li>先取出该查询，如果在内存中则直接返回给执行器，否则先从磁盘读入内存，然后返回</li>
<li>执行器拿到引擎给的行数据，执行相关操作，再调用引擎接口写入这行新数据</li>
<li>引擎将这行新数据更新到内存中，同时将这个更新记录到redo log中，此时redo log处于prepare状态，然后告知执行器执行完成，随时可以提交事务</li>
<li>执行器生成这个操作的binlog，将binlog写入磁盘</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改写提交(commit)状态，更新完成</li>
</ol>
<p>流程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">获取数据 ——&gt; 返回数据 ——&gt; 执行逻辑 ——&gt; 写入新行 ——&gt; 新行更新到内存 ——&gt; 写入redo log处于prepare状态 ——&gt; 写binlog ——&gt; 提交事务redo log处于commit状态完成</div></pre></td></tr></table></figure></p>
<p>redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致</p>
<p>数据一致性保持理解：</p>
<p>1 prepare阶段<br>2 写binlog<br>3 commit</p>
<p>当在2之前崩溃时<br>重启恢复：后发现没有commit，回滚。备份恢复：没有binlog 一致<br>当在3之前崩溃<br>重启恢复：虽没有commit，但满足prepare和binlog完整，所以重启后会自动commit。备份：有binlog. 一致</p>
<p><strong>参数配置</strong><br>innodb_flush_log_at_trx_commit 参数设置成1时，表示每次事务的redo log都直接持久化到磁盘，保证mysql异常重启后数据不丢失<br>sync_binlog参数设置成1时，表示每次事务的binlog都持久化到磁盘，保证mysql异常重启后binlog不丢失</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;WAL(Write-Ahead-Logging),先写日志，再写磁盘&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;redo log(重做日志)&lt;ul&gt;
&lt;li&gt;存储引擎层面&lt;/li&gt;
&lt;li&gt;存储容量大小固定，循环写&lt;/li&gt;
&lt;li&gt;checkpoint 当前要擦除的位置，擦除记录前需要将
    
    </summary>
    
      <category term="Mysql" scheme="https://ttxsgoto.github.io/categories/Mysql/"/>
    
    
      <category term="binlog" scheme="https://ttxsgoto.github.io/tags/binlog/"/>
    
  </entry>
  
  <entry>
    <title>索引选择</title>
    <link href="https://ttxsgoto.github.io/2018/12/21/yw-mysql-select-index/"/>
    <id>https://ttxsgoto.github.io/2018/12/21/yw-mysql-select-index/</id>
    <published>2018-12-21T03:14:08.000Z</published>
    <updated>2018-12-21T03:16:46.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="优化器选择索引逻辑"><a href="#优化器选择索引逻辑" class="headerlink" title="优化器选择索引逻辑"></a>优化器选择索引逻辑</h4><ul>
<li>扫描行数</li>
<li>使用临时表</li>
<li>是否排序</li>
</ul>
<h4 id="基数"><a href="#基数" class="headerlink" title="基数"></a>基数</h4><p>一个索引上不同值的个数，称之为“基数(cardinality)”;基数越大，索引的区分度越好</p>
<p>show index from x 查看索引对应的基数</p>
<ul>
<li>采样统计， 通过设置参数innodb_stats_persistent来设置  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">设置为on，表示统计信息会持久化存储，默认值N为20，M为10</div><div class="line">设置为off, 表示统计信息只存储在内存中，默认值N为8，M为16</div></pre></td></tr></table></figure>
</li>
</ul>
<p>analyze table t # 用于重新统计索引信息，当发现explain中rows值和实际情况差距比较大时，可以采用使用该命令来处理</p>
<h4 id="索引选择异常和处理"><a href="#索引选择异常和处理" class="headerlink" title="索引选择异常和处理"></a>索引选择异常和处理</h4><ul>
<li><p>使用force index强制选择一个索引</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select * from t force index(a) where a between 1000 and 2000;</div></pre></td></tr></table></figure>
</li>
<li><p>修改查询语句</p>
</li>
<li>新建更合适的索引，来提供优化器来选择，或者删掉误用的索引</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;优化器选择索引逻辑&quot;&gt;&lt;a href=&quot;#优化器选择索引逻辑&quot; class=&quot;headerlink&quot; title=&quot;优化器选择索引逻辑&quot;&gt;&lt;/a&gt;优化器选择索引逻辑&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;扫描行数&lt;/li&gt;
&lt;li&gt;使用临时表&lt;/li&gt;
&lt;li&gt;是否排序&lt;/l
    
    </summary>
    
      <category term="Mysql" scheme="https://ttxsgoto.github.io/categories/Mysql/"/>
    
    
      <category term="Index" scheme="https://ttxsgoto.github.io/tags/Index/"/>
    
  </entry>
  
  <entry>
    <title>普通索引和唯一索引的区别</title>
    <link href="https://ttxsgoto.github.io/2018/12/20/yw-mysql-unique-index/"/>
    <id>https://ttxsgoto.github.io/2018/12/20/yw-mysql-unique-index/</id>
    <published>2018-12-20T12:11:46.000Z</published>
    <updated>2018-12-27T10:05:34.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><ul>
<li>查找到满足条件的第一个记录，在查找下一个记录，直到到不满足记录时停止</li>
<li>唯一索引，找到第一个满足条件记录，停止检索</li>
</ul>
<h4 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h4><p>change buffer:如果数据页没有在内存中，innodb会将更新操作缓存在change buffer中，这样不需要从磁盘中读取数据页；下次查询访问这个数据页时，将数据页读入内存，然后执行change buffer中和这个页有关的操作</p>
<ul>
<li>唯一索引更新操作不能使用change buffer，因为判断记录是否存在，必须将数据页读入内存，只有普通索引更新操作可以使用change buffer</li>
<li>change buffer使用的是buffer pool里的内存，大小可以通过参数<strong>innodb_change_buffer_max_size</strong>来设置</li>
</ul>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><ol>
<li>记录要更新的目标页在内存中，此时插入操作基本一致，从内存中读取数据对应的位置，执行插入语句</li>
<li>记录要更新的目标页不在内存中<ul>
<li>唯一索引，需要将数据页读入到内存，判断有没有冲突，执行语句</li>
<li>普通索引，将更新记录到change buffer，执行语句</li>
</ul>
</li>
</ol>
<p>将数据从磁盘读入内存涉及到随机IO访问，成本高；change buffer减少了随机磁盘访问，所以对更新性能的提升更明显</p>
<h4 id="change-buffer使用场景"><a href="#change-buffer使用场景" class="headerlink" title="change buffer使用场景"></a>change buffer使用场景</h4><p>适用于写多读少的业务场景，写入后不立即读取，常见业务系统如日志、账单类系统</p>
<p>如果业务更新后马上需要做查询，即更新先记录change buffer，之后查询这个数据页，会立刻触发merge操作，这样随机访问io次数不会减少，反而增加了change buffer的维护代价</p>
<h4 id="索引选择"><a href="#索引选择" class="headerlink" title="索引选择"></a>索引选择</h4><ul>
<li>查询性能方面无差异</li>
<li>更新操作，因为有change buffer机制，所以普通索引更新操作性能更好</li>
</ul>
<h4 id="change-buffer-amp-amp-redo-log"><a href="#change-buffer-amp-amp-redo-log" class="headerlink" title="change buffer &amp;&amp; redo log"></a>change buffer &amp;&amp; redo log</h4><ul>
<li>redo log 主要节省的是随机写磁盘IO消耗(转成顺序写)</li>
<li>change buffer主要节省的是随机读磁盘io的消耗</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;查询操作&quot;&gt;&lt;a href=&quot;#查询操作&quot; class=&quot;headerlink&quot; title=&quot;查询操作&quot;&gt;&lt;/a&gt;查询操作&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;查找到满足条件的第一个记录，在查找下一个记录，直到到不满足记录时停止&lt;/li&gt;
&lt;li&gt;唯一索引，找到第一个满足
    
    </summary>
    
      <category term="Mysql" scheme="https://ttxsgoto.github.io/categories/Mysql/"/>
    
    
      <category term="Index" scheme="https://ttxsgoto.github.io/tags/Index/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 出现You can&#39;t specify target table for update in FROM clause错误的解决方法</title>
    <link href="https://ttxsgoto.github.io/2018/12/03/yw-mysql-question/"/>
    <id>https://ttxsgoto.github.io/2018/12/03/yw-mysql-question/</id>
    <published>2018-12-03T12:22:02.000Z</published>
    <updated>2018-12-03T02:30:46.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h4><p>在同一个sql语句中，先select同一个表的某些值，然后再update这个表</p>
<p>如执行如下sql语句：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">update logistic_statistic set fluid_id=<span class="string">'cca03b6a372045f2891fef62d9524652'</span> where id <span class="keyword">in</span> (</div><div class="line">  select id <span class="keyword">from</span> logistic_statistic where company= <span class="string">'新能源有限公司'</span>);</div></pre></td></tr></table></figure></p>
<p>执行报错：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error : You can<span class="string">'t specify target table '</span>logistic_statistic<span class="string">' for update in FROM clause</span></div></pre></td></tr></table></figure></p>
<h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><p>select的结果再通过一个中间表select多一次，就可以避免这个错误</p>
<p>执行如下sql语句：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">update logistic_statistic set fluid_id=<span class="string">"cca03b6a372045f2891fef62d9524652"</span> where id <span class="keyword">in</span> ( </div><div class="line">  select other_id <span class="keyword">from</span> ( </div><div class="line">    SELECT id <span class="keyword">as</span> other_id <span class="keyword">from</span> logistic_statistic where company= <span class="string">'新能源有限公司'</span>) <span class="keyword">as</span> a ;</div><div class="line">  );</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;问题描述：&quot;&gt;&lt;a href=&quot;#问题描述：&quot; class=&quot;headerlink&quot; title=&quot;问题描述：&quot;&gt;&lt;/a&gt;问题描述：&lt;/h4&gt;&lt;p&gt;在同一个sql语句中，先select同一个表的某些值，然后再update这个表&lt;/p&gt;
&lt;p&gt;如执行如下sql语句：
    
    </summary>
    
      <category term="Mysql" scheme="https://ttxsgoto.github.io/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="https://ttxsgoto.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Django+Celery 计划任务</title>
    <link href="https://ttxsgoto.github.io/2018/10/24/python-django-celery/"/>
    <id>https://ttxsgoto.github.io/2018/10/24/python-django-celery/</id>
    <published>2018-10-24T14:38:48.000Z</published>
    <updated>2018-10-25T02:00:50.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>需求为工作流审批，到达某状态后，超过一段时间没有审批，则流程自动审批到下一个状态</p>
<h4 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h4><p>想到使用计划任务来自动流转流程，因为项目本身是Django，这里使用djcelery来完成</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>项目依赖<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pip install django-celery</div><div class="line">pip install flower</div></pre></td></tr></table></figure></p>
<p>settings.py配置<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">INSTALLED_APPS = (</div><div class="line">   ...</div><div class="line">   <span class="string">'djcelery'</span>,</div><div class="line">)</div><div class="line"> </div><div class="line"><span class="keyword">import</span> djcelery</div><div class="line"> </div><div class="line">djcelery.setup_loader()</div><div class="line">BROKER_URL = <span class="string">'redis://127.0.0.1:6379/1'</span></div><div class="line">CELERYBEAT_SCHEDULER = <span class="string">'djcelery.schedulers.DatabaseScheduler'</span></div><div class="line"><span class="comment"># CELERY_RESULT_BACKEND = 'djcelery.backends.database:DatabaseBackend'    # 结果存储，存储到数据库</span></div><div class="line">CELERY_RESULT_BACKEND = <span class="string">'redis://127.0.0.1:6379/1'</span></div><div class="line">CELERY_ACCEPT_CONTENT = [<span class="string">'application/json'</span>]</div><div class="line">CELERY_TASK_SERIALIZER = <span class="string">'json'</span></div><div class="line">CELERY_RESULT_SERIALIZER = <span class="string">'json'</span></div><div class="line">CELERY_TIMEZONE = <span class="string">'Asia/Shanghai'</span></div><div class="line"> </div><div class="line">CELERY_TASK_RESULT_EXPIRES = <span class="number">3600</span>  <span class="comment"># celery任务执行结果的超时时间，</span></div><div class="line">CELERYD_FORCE_EXECV = <span class="keyword">True</span>  <span class="comment"># 有些情况下可以防止死锁</span></div><div class="line">CELERYD_PREFETCH_MULTIPLIER = <span class="number">1</span></div><div class="line">CELERYD_MAX_TASKS_PER_CHILD = <span class="number">100</span>   <span class="comment"># 每个worker最多执行万100个任务就会被销毁，可防止内存泄露</span></div><div class="line"><span class="comment"># CELERYD_CONCURRENCY = 10  # celery worker的并发数 也是命令行-c指定的数目,事实上实践发现并不是worker也多越好,保证任务不堆积,加上一定新增任务的预留就可以</span></div></pre></td></tr></table></figure></p>
<p>接下来在settings.py的同级目录中新建 celery.py文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import, unicode_literals</div><div class="line"><span class="keyword">import</span> os</div><div class="line"> </div><div class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</div><div class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</div><div class="line"> </div><div class="line">os.environ.setdefault(<span class="string">'DJANGO_SETTINGS_MODULE'</span>, <span class="string">'Server.settings'</span>)</div><div class="line"> </div><div class="line">app = Celery(<span class="string">'Server'</span>) <span class="comment">#, backend='redis', broker='redis://127.0.0.1:6379/1')</span></div><div class="line">app.config_from_object(<span class="string">'django.conf:settings'</span>)</div><div class="line">app.autodiscover_tasks(<span class="keyword">lambda</span>: settings.INSTALLED_APPS)</div></pre></td></tr></table></figure>
<p>修改<strong>init</strong>.py添加<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import, unicode_literals</div><div class="line">  </div><div class="line"><span class="keyword">from</span> .celery <span class="keyword">import</span> app <span class="keyword">as</span> celery_app</div></pre></td></tr></table></figure></p>
<p>在对应的app中添加tasks.py文件(这里必须为tasks.py文件，不然在admin中添加任务时找不到task)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import, unicode_literals</div><div class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> shared_task, task</div><div class="line">  </div><div class="line"><span class="meta">@shared_task</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">auto_audit</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">'func auto audit'</span>)</div><div class="line"> </div><div class="line"><span class="meta">@task()</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></div><div class="line">    print(<span class="string">'x + y = '</span>, x + y)</div><div class="line">    <span class="keyword">return</span> x + y</div></pre></td></tr></table></figure></p>
<p>在views.py中调用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> .tasks <span class="keyword">import</span> add</div><div class="line">  </div><div class="line">add.delay(<span class="number">3</span>, <span class="number">5</span>) <span class="comment">#发送消息，触发后台任务</span></div></pre></td></tr></table></figure></p>
<p>celery启动，当然实际环境中应该使用supervisor启动<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">python manage.py celery worker -l info  <span class="comment"># 启动 worker</span></div><div class="line">python manage.py celery beat -l info    <span class="comment"># 启动 beat</span></div><div class="line">python manage.py celery worker -B -l info  <span class="comment"># 启动 worker 和 beat</span></div><div class="line">python manage.py celery flower --address=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> --port=<span class="number">5555</span> --basic_auth=admin:admin    <span class="comment"># 启动celery flower监控</span></div></pre></td></tr></table></figure></p>
<h4 id="Admin后台添加计划任务"><a href="#Admin后台添加计划任务" class="headerlink" title="Admin后台添加计划任务"></a>Admin后台添加计划任务</h4><p>在DJCELERY中Periodic tasks添加计划任务即可</p>
<h4 id="Flower监控celery"><a href="#Flower监控celery" class="headerlink" title="Flower监控celery"></a>Flower监控celery</h4><p>主要用于监控任务执行是否成功，和broker和worker对应的状态</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;p&gt;需求为工作流审批，到达某状态后，超过一段时间没有审批，则流程自动审批到下一个状态&lt;/p&gt;
&lt;h4 id=&quot;方案&quot;&gt;&lt;a href=&quot;#方案&quot;
    
    </summary>
    
      <category term="Django" scheme="https://ttxsgoto.github.io/categories/Django/"/>
    
    
      <category term="Djcelery" scheme="https://ttxsgoto.github.io/tags/Djcelery/"/>
    
  </entry>
  
  <entry>
    <title>运维 Redis进阶</title>
    <link href="https://ttxsgoto.github.io/2018/09/28/redis-advance/"/>
    <id>https://ttxsgoto.github.io/2018/09/28/redis-advance/</id>
    <published>2018-09-28T13:14:53.000Z</published>
    <updated>2018-09-29T02:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>Redis的数据存在内存中， 读写速度非常快，常用于缓存数据，来提高系统的高性能和高并发</p>
<h4 id="使用redis目的"><a href="#使用redis目的" class="headerlink" title="使用redis目的"></a>使用redis目的</h4><ul>
<li>高性能：将数据缓存在redis中，访问数据从缓存中取，不直接访问数据库，提高页面响应效率</li>
<li>高并发：在大的并发情况下，直接操作缓存能够承受的请求远大于直接访问数据库，这时我们需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库</li>
</ul>
<h4 id="一般应用场景"><a href="#一般应用场景" class="headerlink" title="一般应用场景"></a>一般应用场景</h4><ul>
<li>缓存-热数据：需要执行耗时久，计算结果不频繁变动的sql查询</li>
<li>异步队列</li>
<li>计数器：如统计点击数，INCRBY</li>
<li>分布式锁与单线程机制</li>
<li>最新列表：使用LPUSH命令构建List</li>
<li>排行榜应用： 使用ZADD(有续集，sorted set)</li>
<li>位操作(大数据处理)</li>
</ul>
<h4 id="单线程的redis为什么快"><a href="#单线程的redis为什么快" class="headerlink" title="单线程的redis为什么快"></a>单线程的redis为什么快</h4><ul>
<li>纯内存操作</li>
<li>单线程操作，避免了频繁的上下文切换</li>
<li><p>采用非阻塞I/O多路复用机制</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">在redis服务端，启用了I/O多路复用机制，将其置于队列中，然后文件事件分发器依次去队列中去取，转发到不同的事件处理器中处理</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="常见数据结构和使用场景"><a href="#常见数据结构和使用场景" class="headerlink" title="常见数据结构和使用场景"></a>常见数据结构和使用场景</h4><ul>
<li>String </li>
</ul>
<p>常用的命令： set、get、decr、incr、mget、mset<br>String 数据结构是简单的 Key-Value 类型，Value 可为字符和数值和其他类型的值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 设置和获取key-value</span></div><div class="line">set mykey ttxsgoto</div><div class="line">get mykey</div><div class="line"> </div><div class="line"><span class="comment"># 原子递增</span></div><div class="line">set counter <span class="number">100</span></div><div class="line">incr counter ((integer) <span class="number">101</span>)</div><div class="line"> </div><div class="line"><span class="comment"># 一次性存储和获取多个key对应的值,mget 命令返回由值组成的数组</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; mset a <span class="number">10</span> b <span class="number">20</span> c <span class="number">30</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; mget a b c</div><div class="line"><span class="number">1</span>) <span class="string">"10"</span></div><div class="line"><span class="number">2</span>) <span class="string">"20"</span></div><div class="line"><span class="number">3</span>) <span class="string">"30"</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; keys *</div><div class="line"><span class="number">1</span>) <span class="string">"ttxs"</span></div><div class="line"><span class="number">2</span>) <span class="string">"c"</span></div><div class="line"><span class="number">3</span>) <span class="string">"a"</span></div><div class="line"><span class="number">4</span>) <span class="string">"counter"</span></div><div class="line"><span class="number">5</span>) <span class="string">"b"</span></div><div class="line"><span class="number">6</span>) <span class="string">"mykey"</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; exists a</div><div class="line">(integer) <span class="number">1</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; exists x</div><div class="line">(integer) <span class="number">0</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; type a</div><div class="line">string</div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="keyword">del</span> a</div><div class="line">(integer) <span class="number">1</span></div><div class="line"> </div><div class="line"><span class="comment"># 设置过期时间</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get b</div><div class="line"><span class="string">"20"</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; expire b <span class="number">5</span></div><div class="line">(integer) <span class="number">1</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get b</div><div class="line">(nil)</div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; set bbb <span class="number">1000</span> ex <span class="number">100</span></div><div class="line">OK</div><div class="line"><span class="comment"># 查看过期时间</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; ttl bbb</div><div class="line">(integer) <span class="number">95</span></div></pre></td></tr></table></figure></p>
<ul>
<li>Hash</li>
</ul>
<p>常用命令：hget、hset、 hmget、hmset、hgetall<br>Hash 是一个 String 类型的 Field 和 Value 的映射表，Hash 特别适合用于存储对象；后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 由键值对组成</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hmset user:<span class="number">1000</span> username antirez birthyear <span class="number">1977</span> verified <span class="number">1</span></div><div class="line">OK</div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hget user:<span class="number">1000</span> username</div><div class="line"><span class="string">"antirez"</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hgetall user:<span class="number">1000</span></div><div class="line"><span class="number">1</span>) <span class="string">"username"</span></div><div class="line"><span class="number">2</span>) <span class="string">"antirez"</span></div><div class="line"><span class="number">3</span>) <span class="string">"birthyear"</span></div><div class="line"><span class="number">4</span>) <span class="string">"1977"</span></div><div class="line"><span class="number">5</span>) <span class="string">"verified"</span></div><div class="line"><span class="number">6</span>) <span class="string">"1"</span></div><div class="line"> </div><div class="line"><span class="comment"># 返回多个值</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hmget user:<span class="number">1000</span> username birthyear xxx</div><div class="line"><span class="number">1</span>) <span class="string">"antirez"</span></div><div class="line"><span class="number">2</span>) <span class="string">"1977"</span></div><div class="line"><span class="number">3</span>) (nil)</div></pre></td></tr></table></figure></p>
<ul>
<li>List</li>
</ul>
<p>常用命令：lpush、rpush、lpop、rpop、lrange<br>List 就是链表，Redis List 的应用场景非常多，也是 Redis 最重要的数据结构之一<br>Redis List 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销<br>另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 List 实现分页查询</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># lpush 向list的左边（头部）添加一个新元素</span></div><div class="line"><span class="comment"># rpush 向list的右边（尾部）添加一个新元素</span></div><div class="line"><span class="comment"># lrange 从list中取出一定范围的元素</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; rpush mylist A</div><div class="line">(integer) <span class="number">1</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; rpush mylist B</div><div class="line">(integer) <span class="number">2</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lpush mylist first</div><div class="line">(integer) <span class="number">3</span></div><div class="line"><span class="comment"># </span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lrange mylist <span class="number">0</span> <span class="number">-1</span></div><div class="line"><span class="number">1</span>) <span class="string">"first"</span></div><div class="line"><span class="number">2</span>) <span class="string">"A"</span></div><div class="line"><span class="number">3</span>) <span class="string">"B"</span></div><div class="line"><span class="comment"># 写入多个值</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; rpush mylist <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="string">"foo bar"</span></div><div class="line">(integer) <span class="number">9</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lrange mylist <span class="number">0</span> <span class="number">-1</span></div><div class="line"><span class="number">1</span>) <span class="string">"first"</span></div><div class="line"><span class="number">2</span>) <span class="string">"A"</span></div><div class="line"><span class="number">3</span>) <span class="string">"B"</span></div><div class="line"><span class="number">4</span>) <span class="string">"1"</span></div><div class="line"><span class="number">5</span>) <span class="string">"2"</span></div><div class="line"><span class="number">6</span>) <span class="string">"3"</span></div><div class="line"><span class="number">7</span>) <span class="string">"4"</span></div><div class="line"><span class="number">8</span>) <span class="string">"5"</span></div><div class="line"><span class="number">9</span>) <span class="string">"foo bar"</span></div><div class="line"> </div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; rpush mylist001 a b c</div><div class="line"><span class="comment"># 删除元素并同时返回删除的值</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; rpop mylist001</div><div class="line"><span class="string">"c"</span></div><div class="line"> </div><div class="line"><span class="comment"># ltrim把list从左边截取指定长度</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; ltrim mylist <span class="number">0</span> <span class="number">2</span></div><div class="line">OK</div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LRANGE mylist <span class="number">0</span> <span class="number">-1</span></div><div class="line"><span class="number">1</span>) <span class="string">"first"</span></div><div class="line"><span class="number">2</span>) <span class="string">"A"</span></div><div class="line"><span class="number">3</span>) <span class="string">"B"</span></div><div class="line"><span class="comment"># 查看list中元素的个数</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; llen mylist</div><div class="line">(integer) <span class="number">6</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="keyword">del</span> mylist</div><div class="line">(integer) <span class="number">1</span></div></pre></td></tr></table></figure>
<ul>
<li>Set</li>
</ul>
<p>常用命令：sadd、spop、smembers、sunion<br>Set 对外提供的功能与 List 类似是一个列表的功能，特殊之处在于 Set 是可以自动排重<br>当你需要存储一个列表数据，又不希望出现重复数据时，可以使用Set，同时也支持交集、并集、差集操作<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 添加</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd myset <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></div><div class="line">(integer) <span class="number">3</span></div><div class="line"><span class="comment"># 查看所有</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers myset</div><div class="line"><span class="number">1</span>) <span class="string">"1"</span></div><div class="line"><span class="number">2</span>) <span class="string">"2"</span></div><div class="line"><span class="number">3</span>) <span class="string">"3"</span></div><div class="line"><span class="comment"># 检查元素是否存在</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sismember myset <span class="number">1</span></div><div class="line">(integer) <span class="number">1</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sismember myset <span class="number">4</span></div><div class="line">(integer) <span class="number">0</span></div></pre></td></tr></table></figure></p>
<ul>
<li>Sorted Set</li>
</ul>
<p>常用命令：zadd、zrange、zrem、zcard<br>和 Set 相比，Sorted Set 增加了一个权重参数 Score，使得集合中的元素能够按 Score 进行有序排列<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># zadd 添加</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd hackers <span class="number">1940</span> <span class="string">"Alan Kay"</span></div><div class="line">(integer) <span class="number">1</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd hackers <span class="number">1957</span> <span class="string">"Sophie Wilson"</span></div><div class="line">(integer) <span class="number">1</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd hackers <span class="number">1953</span> <span class="string">"Richard Stallman"</span></div><div class="line">(integer) <span class="number">1</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd hackers <span class="number">1949</span> <span class="string">"Anita Borg"</span></div><div class="line">(integer) <span class="number">1</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd hackers <span class="number">1965</span> <span class="string">"Yukihiro Matsumoto"</span></div><div class="line">(integer) <span class="number">1</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd hackers <span class="number">1914</span> <span class="string">"Hedy Lamarr"</span></div><div class="line">(integer) <span class="number">1</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd hackers <span class="number">1916</span> <span class="string">"Claude Shannon"</span></div><div class="line">(integer) <span class="number">1</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd hackers <span class="number">1969</span> <span class="string">"Linus Torvalds"</span></div><div class="line">(integer) <span class="number">1</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd hackers <span class="number">1912</span> <span class="string">"Alan Turing"</span></div><div class="line">(integer) <span class="number">1</span></div><div class="line"> </div><div class="line"><span class="comment"># 查看数据</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrange hackers <span class="number">0</span> <span class="number">-1</span></div><div class="line"><span class="number">1</span>) <span class="string">"Alan Turing"</span></div><div class="line"><span class="number">2</span>) <span class="string">"Hedy Lamarr"</span></div><div class="line"><span class="number">3</span>) <span class="string">"Claude Shannon"</span></div><div class="line"><span class="number">4</span>) <span class="string">"Alan Kay"</span></div><div class="line"><span class="number">5</span>) <span class="string">"Anita Borg"</span></div><div class="line"><span class="number">6</span>) <span class="string">"Richard Stallman"</span></div><div class="line"><span class="number">7</span>) <span class="string">"Sophie Wilson"</span></div><div class="line"><span class="number">8</span>) <span class="string">"Yukihiro Matsumoto"</span></div><div class="line"><span class="number">9</span>) <span class="string">"Linus Torvalds"</span></div><div class="line"> </div><div class="line"><span class="comment"># 反向查看数据</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrevrange hackers <span class="number">0</span> <span class="number">-1</span></div><div class="line"><span class="number">1</span>) <span class="string">"Linus Torvalds"</span></div><div class="line"><span class="number">2</span>) <span class="string">"Yukihiro Matsumoto"</span></div><div class="line"><span class="number">3</span>) <span class="string">"Sophie Wilson"</span></div><div class="line"><span class="number">4</span>) <span class="string">"Richard Stallman"</span></div><div class="line"><span class="number">5</span>) <span class="string">"Anita Borg"</span></div><div class="line"><span class="number">6</span>) <span class="string">"Alan Kay"</span></div><div class="line"><span class="number">7</span>) <span class="string">"Claude Shannon"</span></div><div class="line"><span class="number">8</span>) <span class="string">"Hedy Lamarr"</span></div><div class="line"><span class="number">9</span>) <span class="string">"Alan Turing"</span></div><div class="line"> </div><div class="line"><span class="comment"># 查看对应的得分</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrange hackers <span class="number">0</span> <span class="number">-1</span> withscores</div><div class="line"> <span class="number">1</span>) <span class="string">"Alan Turing"</span></div><div class="line"> <span class="number">2</span>) <span class="string">"1912"</span></div><div class="line"> <span class="number">3</span>) <span class="string">"Hedy Lamarr"</span></div><div class="line"> <span class="number">4</span>) <span class="string">"1914"</span></div><div class="line"> <span class="number">5</span>) <span class="string">"Claude Shannon"</span></div><div class="line"> <span class="number">6</span>) <span class="string">"1916"</span></div><div class="line"> <span class="number">7</span>) <span class="string">"Alan Kay"</span></div><div class="line"> <span class="number">8</span>) <span class="string">"1940"</span></div><div class="line"> <span class="number">9</span>) <span class="string">"Anita Borg"</span></div><div class="line"><span class="number">10</span>) <span class="string">"1949"</span></div><div class="line"><span class="number">11</span>) <span class="string">"Richard Stallman"</span></div><div class="line"><span class="number">12</span>) <span class="string">"1953"</span></div><div class="line"><span class="number">13</span>) <span class="string">"Sophie Wilson"</span></div><div class="line"><span class="number">14</span>) <span class="string">"1957"</span></div><div class="line"><span class="number">15</span>) <span class="string">"Yukihiro Matsumoto"</span></div><div class="line"><span class="number">16</span>) <span class="string">"1965"</span></div><div class="line"><span class="number">17</span>) <span class="string">"Linus Torvalds"</span></div><div class="line"><span class="number">18</span>) <span class="string">"1969"</span></div><div class="line">  </div><div class="line"><span class="comment"># 小于1950的数据</span></div><div class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrangebyscore hackers -inf <span class="number">1950</span></div><div class="line"><span class="number">1</span>) <span class="string">"Alan Turing"</span></div><div class="line"><span class="number">2</span>) <span class="string">"Hedy Lamarr"</span></div><div class="line"><span class="number">3</span>) <span class="string">"Claude Shannon"</span></div><div class="line"><span class="number">4</span>) <span class="string">"Alan Kay"</span></div><div class="line"><span class="number">5</span>) <span class="string">"Anita Borg"</span></div></pre></td></tr></table></figure></p>
<h4 id="过期策略以及内存淘汰机制"><a href="#过期策略以及内存淘汰机制" class="headerlink" title="过期策略以及内存淘汰机制"></a>过期策略以及内存淘汰机制</h4><p>redis采用的是定期删除+惰性删除策略</p>
<ul>
<li>定期删除：Redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 Key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机？假如 Redis 存了几十万个 Key ，每隔 100ms 就遍历所有的设置过期时间的 Key 的话，就会给 CPU 带来很大的负载</li>
<li><p>惰性删除 ：定期删除可能会导致很多过期 Key 到了时间并没有被删除掉。所以就有了惰性删除，也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除</p>
</li>
<li><p>内存淘汰机制： 在redis配置文件中配置 # maxmemory-policy volatile-lru<br>Redis 提供 6 种数据淘汰策略：</p>
</li>
</ul>
<pre><code>- volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
- volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
- volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
- allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）
- allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
- no-enviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错
</code></pre><h4 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h4><p>Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file，AOF）。</p>
<ul>
<li><p>RDB 快照持久化是 Redis 默认采用的持久化方式，在 redis.conf 配置文件中默认有此下配置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">save <span class="number">900</span> <span class="number">1</span>              <span class="comment">#在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span></div><div class="line">save <span class="number">300</span> <span class="number">10</span>            <span class="comment">#在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span></div><div class="line">save <span class="number">60</span> <span class="number">10000</span>        <span class="comment">#在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span></div></pre></td></tr></table></figure>
</li>
<li><p>AOF<br>与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案<br>默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">appendonly yes</div></pre></td></tr></table></figure>
</li>
</ul>
<p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入硬盘中的 AOF 文件。</p>
<p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。</p>
<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">appendfsync always     <span class="comment">#每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span></div><div class="line">appendfsync everysec  <span class="comment">#每秒钟同步一次，显示地将多个写命令同步到硬盘</span></div><div class="line">appendfsync no      <span class="comment">#让操作系统决定何时进行同步</span></div></pre></td></tr></table></figure></p>
<p>为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。</p>
<ul>
<li>Redis 4.0 对于持久化机制的优化</li>
</ul>
<p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 aof-use-rdb-preamble 开启）。</p>
<p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。</p>
<p>这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。</p>
<p>当然缺点也是有的，AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>当缓存失效(过期)后引起系统性能急剧下降的情况</p>
<p>解决方案：</p>
<ul>
<li><p>更新锁机制</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">对缓存更新操作进行加锁保护，保证只有一个线程进行缓存更新，未能获取更新锁的线程要么等待锁释放后重新读取缓存，要么返回一个空值或者默认值</div></pre></td></tr></table></figure>
</li>
<li><p>后台更新机制</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">由后台线程更新缓存， 不是由业务来更新缓存，缓存本身的有效期设置为永久，后台线程定时更新缓存</div></pre></td></tr></table></figure>
</li>
<li><p>给缓存的失效时间加一个随机值，避免集体失效</p>
</li>
<li>使用双缓存，缓存A和B,A设置失效时间，B不设置失效  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- 从缓存A读取数据，有就返回</div><div class="line">- A没有数据，直接从B读取数据，直接返回，并异步启动一个更新线程</div><div class="line">- 更新线程同时更新A，B的缓存数据</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉</p>
<p>解决方案：</p>
<ul>
<li>利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试</li>
<li>采用异步更新策略，无论key是否取到值，都直接返回，如果查询返回的数据为空也缓存清理。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作</li>
</ul>
<h4 id="如何解决redis的并发竞争key问题"><a href="#如何解决redis的并发竞争key问题" class="headerlink" title="如何解决redis的并发竞争key问题"></a>如何解决redis的并发竞争key问题</h4><p>所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 Key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同</p>
<p>推荐方案： 分布式锁（ZooKeeper 和 Redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能），大家去抢锁，抢到锁就做set操作即可；</p>
<h4 id="redis和数据库双写一致性问题"><a href="#redis和数据库双写一致性问题" class="headerlink" title="redis和数据库双写一致性问题"></a>redis和数据库双写一致性问题</h4><p>首先，采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul>
<li><a href="http://www.redis.cn/topics/data-types-intro.html#strings" target="_blank" rel="external">http://www.redis.cn/topics/data-types-intro.html#strings</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis的数据存在内存中， 读写速度非常快，常用于缓存数据，来提高系统的高性能和高并发&lt;/p&gt;
&lt;h4 id=&quot;使用redis目的&quot;&gt;&lt;a href=&quot;#使用redis目的&quot; class=&quot;headerlink&quot; title=&quot;使用redis目的&quot;&gt;&lt;/a&gt;使用redis
    
    </summary>
    
      <category term="运维" scheme="https://ttxsgoto.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Redis" scheme="https://ttxsgoto.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Django mgirate 错误</title>
    <link href="https://ttxsgoto.github.io/2018/09/17/django-migrations-error/"/>
    <id>https://ttxsgoto.github.io/2018/09/17/django-migrations-error/</id>
    <published>2018-09-17T11:37:18.000Z</published>
    <updated>2018-09-17T12:38:18.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>最近在工作中，django model添加表时，如果有外键，在migrate时常常出现如下报错：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">File <span class="string">"/root/.virtualenvs/lib/python3.5/site-packages/pymysql/connections.py"</span>, line <span class="number">1057</span>, <span class="keyword">in</span> _read_query_result</div><div class="line">    result.read()</div><div class="line">  File <span class="string">"/root/.virtualenvs/lib/python3.5/site-packages/pymysql/connections.py"</span>, line <span class="number">1340</span>, <span class="keyword">in</span> read</div><div class="line">    first_packet = self.connection._read_packet()</div><div class="line">  File <span class="string">"/root/.virtualenvs/lib/python3.5/site-packages/pymysql/connections.py"</span>, line <span class="number">1014</span>, <span class="keyword">in</span> _read_packet</div><div class="line">    packet.check_error()</div><div class="line">  File <span class="string">"/root/.virtualenvs/lib/python3.5/site-packages/pymysql/connections.py"</span>, line <span class="number">393</span>, <span class="keyword">in</span> check_error</div><div class="line">    err.raise_mysql_exception(self._data)</div><div class="line">  File <span class="string">"/root/.virtualenvs/lib/python3.5/site-packages/pymysql/err.py"</span>, line <span class="number">107</span>, <span class="keyword">in</span> raise_mysql_exception</div><div class="line">    <span class="keyword">raise</span> errorclass(errno, errval)</div><div class="line">django.db.utils.IntegrityError: (<span class="number">1215</span>, <span class="string">'Cannot add foreign key constraint'</span>)</div></pre></td></tr></table></figure></p>
<h4 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h4><p>查看资料后，网上大体出现这样报错的原因有：</p>
<ul>
<li>外键对应的字段数据类型不一致</li>
<li>两张表的存储引擎不一致</li>
<li>设置外键时“删除时”设置为“SET NULL”</li>
</ul>
<p>发现这3点都不是引起我们报错的原因，首先我们的外键的字段都是UUID类型一样， 存储引擎也同样都是InnoDB,外键使用默认的django.db.models.deletion.CASCADE，这3点都不是造成错误的原因；</p>
<p>后来通过反复比较， 发现发现新建的表和建立外键的关系表中对应的字符集(default character set)和默认集合(default collation)这两者的类型不一致，导致外键关系创建不上,修改成一致后，再migrate，问题解决<br>所以 在这里应该再加一条，</p>
<ul>
<li>在导入新库时，对应的字符集和集合类型应该和原数据库一致</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在开发环境中，常把线上的数据库导入开发环境中， 这样本地数据库的字符集和集合类型有可能和线上的就不一致，导致上述问题；<br>上述问题的原因： 线上数据库在创建数据库时指定的字符集为(utf8mb4)集合类型为(utf8mb4_general_ci),而在本地创建数据库时指定的字符集类型为(utf8mb4)集合类型为(utf8mb4_bin); 尤其在多人协作时这样的问题更容易出现，所以这样的操作时，应先查看数据库对应的存储引擎、字符集和集合类型等信息，避免出现意想不到的错误。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h4&gt;&lt;p&gt;最近在工作中，django model添加表时，如果有外键，在migrate时常常出现如下报错：&lt;br&gt;&lt;figure cl
    
    </summary>
    
      <category term="Django" scheme="https://ttxsgoto.github.io/categories/Django/"/>
    
    
      <category term="migrate" scheme="https://ttxsgoto.github.io/tags/migrate/"/>
    
  </entry>
  
  <entry>
    <title>Mysql必知必会笔记</title>
    <link href="https://ttxsgoto.github.io/2018/09/16/mysql-queryset/"/>
    <id>https://ttxsgoto.github.io/2018/09/16/mysql-queryset/</id>
    <published>2018-09-16T11:02:58.000Z</published>
    <updated>2018-09-17T11:24:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了一下mysql基础知识， 主要集中在相关查询操作上，记录如下：</p>
<p>其中使用的数据库结构和数据为<a href="http://forta.com/books/0672327120/" target="_blank" rel="external">http://forta.com/books/0672327120/</a> 中的SQL脚本</p>
<h4 id="计算次序"><a href="#计算次序" class="headerlink" title="计算次序"></a>计算次序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM products WHERE vend_id=1002 or vend_id =1003;</div><div class="line">SELECT * FROM products WHERE (vend_id=1002 or vend_id=1003) AND prod_price &gt;=10;</div><div class="line">SELECT * FROM products WHERE vend_id not in (1002, 1003) ORDER BY prod_name;</div><div class="line">SELECT * FROM products ;</div><div class="line">SELECT * FROM products WHERE prod_name like &apos;_ ton anv%&apos;;	# _ 只匹配单个字符而不是多个字符</div></pre></td></tr></table></figure>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM products ;</div><div class="line">SELECT * FROM products WHERE prod_name REGEXP &apos;.000&apos; ORDER BY prod_name;	# 匹配任意一个字符</div><div class="line">SELECT * FROM products WHERE prod_name regexp &apos;1000|2000&apos;;</div><div class="line">SELECT * FROM products WHERE prod_name regexp &apos;[123] ton&apos;;</div></pre></td></tr></table></figure>
<h4 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h4><p>拼接： 将值联结到一起构成单个值， 使用Concat()函数来来拼接两个列, 函数中为多个字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT CONCAT(vend_name, &apos; (&apos;, vend_country, &apos;) &apos;) AS vend_title FROM vendors order by vend_name;</div></pre></td></tr></table></figure></p>
<p>执行算术计算<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT prod_id, quantity, item_price, quantity*item_price as total_price FROM orderitems WHERE order_num=20005;</div></pre></td></tr></table></figure></p>
<h4 id="使用数据处理函数"><a href="#使用数据处理函数" class="headerlink" title="使用数据处理函数"></a>使用数据处理函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">日期和时间处理函数</div><div class="line">ADDDATE(expr,days)	添加一个日期(天，周等)</div><div class="line">ADDTIME(expr1,expr2)	添加一个时间(时，分等)</div><div class="line">CURDATE()	返回当前日期</div><div class="line">CURTIME()	返回当前时间</div><div class="line">DATE(expr)	返回日期时间的日期部分</div><div class="line">DATEDIFF(expr1,expr2)	计算两个日期之差</div><div class="line">DATE_ADD(date,INTERVAL expr unit)	高度灵活的日期运算函数</div><div class="line">DATE_FORMAT(date,format)	返回一个格式化的日期或时间串</div><div class="line">DAY(date)	返回一个日期的天数部分</div><div class="line">DAYOFWEEK(date)	对于一个日期，返回对应的星期几</div><div class="line">HOUR(time)	返回一个时间的小时部分</div><div class="line">MINUTE(time)	返回一个时间的分钟部分</div><div class="line">MONTH(date)	返回一个日期的月份部分</div><div class="line">NOW()		返回当前日期和时间</div><div class="line">SECOND(time)	返回一个时间的秒部分</div><div class="line">TIME(expr)	返回一个日期时间的时间部分</div><div class="line">YEAR()		返回一个日期的年份部分</div><div class="line"> </div><div class="line">数值处理函数</div><div class="line">ABS(X)	返回一个数的绝对值</div><div class="line">COS(X)	返回一个角度的余弦</div><div class="line">EXP(X)	返回一个数的指数值</div><div class="line">MOD(N,M)	返回除操作的余数</div><div class="line">PI()	返回圆周率</div><div class="line">RAND()	返回一个随机数</div><div class="line">SIN(X)	返回一个角度的正弦</div><div class="line">SQRT(X)	返回一个数的平方根</div><div class="line">TAN(X)	返回一个角度的正切</div><div class="line"> </div><div class="line">SELECT * FROM orders;</div><div class="line">SELECT * from orders WHERE DATE(order_date) = &apos;2005-09-01&apos;;</div><div class="line">SELECT * FROM orders WHERE DATE(order_date) BETWEEN &apos;2005-09-01&apos; and &apos;2005-10-01&apos;;</div><div class="line">SELECT * from orders where YEAR(order_date)=2005 and MONTH(order_date) = 10;</div></pre></td></tr></table></figure>
<h4 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h4><ul>
<li>聚合函数<br>  运行在行组上，计算和返回单个值的函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">AVG([DISTINCT] expr)	返回某列的平均值</div><div class="line">COUNT(expr)	返回某列的行数</div><div class="line">MAX(expr)	返回某列的最大值</div><div class="line">MIN(expr)	返回某列的最小值</div><div class="line">SUM(expr)	返回某列值之和</div><div class="line"> </div><div class="line"> </div><div class="line">SELECT AVG(prod_price) AS avg_price FROM products WHERE vend_id=1003;</div><div class="line">SELECT COUNT(*) FROM customers;</div><div class="line">SELECT COUNT(cust_email) FROM customers;</div><div class="line">SELECT SUM(item_price* quantity) FROM orderitems WHERE order_num=20005;</div><div class="line">-- 集合不同值 DISTINCT</div><div class="line">SELECT AVG(DISTINCT prod_price) AS avg_price FROM products WHERE vend_id=1003;</div><div class="line">SELECT COUNT(*) AS num_items, MIN(prod_price), MAX(prod_price), AVG(prod_price) FROM products;</div></pre></td></tr></table></figure>
<h4 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h4><ul>
<li>分组允许把数据分为多个逻辑组，以便能对每个组进行聚集计算</li>
<li>WHERE 过滤行， HAVING 过滤分组</li>
<li>WHERE 在数据分组前进行过滤，having在数据分组后进行过滤</li>
<li>GROUP BY子句可以包含任何数目的列</li>
<li>如果在group by子句中嵌套了分组， 数据将在最后规定的分组上进行汇总</li>
<li>GROUP BY子句中列出的每个列都必须是检索列或有效的表达式(单不能是聚集函数)</li>
<li>SELECT 语句中的每个列都必须在group by 子句中给出</li>
<li>如果分组列中具有null值，则null将作为一个分组返回，如果列中有多行null值，它们将分为一组</li>
<li>GROUP BY 子句必须出现在where子句之后，order by子句之前</li>
<li>使用 with rollup关键字， 可以得到每个分组汇总的值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM orders;</div><div class="line">SELECT vend_id, COUNT(*) as num FROM products GROUP BY vend_id WITH ROLLUP;</div><div class="line">SELECT cust_id,COUNT(*) as order_count FROM orders GROUP BY cust_id HAVING order_count &gt;= 2;</div><div class="line">SELECT * FROM products;</div><div class="line">SELECT vend_id,COUNT(*) FROM products WHERE prod_price &gt;=10 GROUP BY vend_id HAVING COUNT(*) &gt;=2;</div></pre></td></tr></table></figure>
<p>SELECT子句及其顺序</p>
<table>
<thead>
<tr>
<th>子句</th>
<th>说明</th>
<th>是否必须使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>SELECT</td>
<td>要返回的列或表达式</td>
<td>是</td>
</tr>
<tr>
<td>FROM</td>
<td>从中检索数据的表</td>
<td>仅在从表选择数据时使用</td>
</tr>
<tr>
<td>WHERE</td>
<td>行级过滤</td>
<td>否</td>
</tr>
<tr>
<td>GROUP BY</td>
<td>分组说明</td>
<td>仅在按组计算聚集时使用</td>
</tr>
<tr>
<td>HAVING</td>
<td>组级过滤</td>
<td>否</td>
</tr>
<tr>
<td>ORDER BY</td>
<td>输出排序顺序</td>
<td>否</td>
</tr>
<tr>
<td>LIMIT</td>
<td>要检索的行数</td>
<td>否</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT order_num, SUM(quantity*item_price) AS total  FROM orderitems GROUP BY order_num HAVING total &gt;=50 ORDER BY total;</div></pre></td></tr></table></figure>
<h4 id="使用子查询"><a href="#使用子查询" class="headerlink" title="使用子查询"></a>使用子查询</h4><p>子查询：嵌套在其他查询中的查询<br>子查询进行过滤<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM orderitems WHERE prod_id=&apos;TNT2&apos;;</div><div class="line">SELECT * FROM orders WHERE order_num in (20005, 20007);</div><div class="line">SELECT cust_id FROM orders WHERE order_num in (SELECT order_num FROM orderitems WHERE prod_id=&apos;TNT2&apos;);</div><div class="line">SELECT cust_name, cust_contact FROM customers WHERE cust_id IN (SELECT cust_id FROM orders WHERE order_num in (SELECT order_num FROM orderitems WHERE prod_id=&apos;TNT2&apos;));</div></pre></td></tr></table></figure></p>
<p>计算字段使用子查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT COUNT(*) AS orders FROM orders WHERE cust_id=10001;</div><div class="line"></div><div class="line">SELECT cust_name, cust_state, (SELECT COUNT(*) FROM orders WHERE orders.cust_id = customers.cust_id) AS orders FROM customers ORDER BY cust_name;</div></pre></td></tr></table></figure>
<h4 id="联结表查询"><a href="#联结表查询" class="headerlink" title="联结表查询"></a>联结表查询</h4><ul>
<li>内部联结： 基于两个表之间的相等测试</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT vend_name, prod_name, prod_price FROM vendors INNER JOIN products ON vendors.vend_id = products.vend_id;</div><div class="line">SELECT prod_name, vend_name, prod_price, quantity FROM orderitems, products, vendors WHERE products.vend_id = vendors.vend_id AND orderitems.prod_id = products.prod_id AND order_num=20005;</div><div class="line">SELECT cust_name, cust_contact FROM customers, orders, orderitems WHERE customers.cust_id = orders.cust_id AND orderitems.order_num = orders.order_num AND prod_id = &apos;TNT2&apos;;</div></pre></td></tr></table></figure>
<h4 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h4><p>利用union操作符将多条select组合成一个结果集<br>使用场景：</p>
<pre><code>- 在单个查询中从不同的表返回类似结构的数据
- 对单个表执行多个查询，按单个查询返回数据
</code></pre><p> 规则：</p>
<ul>
<li>SELECT 语句之间使用UNION关键字连接</li>
<li>UNION每个查询必须包含相同的列、表达式或者聚集函数</li>
<li>列数据类型必须兼容，类型不必完全相同，但必须是DBMS可以隐含地转换类型</li>
<li>UNION 从查询结果中自动去除了重复的行，如果需要返回所有匹配行，可以使用UNION ALL来展示</li>
<li>UNION 只能使用一条ORDER BY 子句，必须出现在最后一条SELECT语句之后,作用于所有SELECT语句返回的结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SELECT vend_id, prod_id, prod_price FROM products WHERE prod_price&lt;=5;</div><div class="line">SELECT vend_id, prod_id, prod_price FROM products WHERE vend_id IN (1001, 1002);</div><div class="line">SELECT vend_id, prod_id, prod_price FROM products WHERE prod_price &lt;=5 UNION ALL SELECT vend_id, prod_id, prod_price FROM products WHERE vend_id IN (1001,1002);</div><div class="line">SELECT vend_id, prod_id, prod_price FROM products WHERE prod_price&lt;=5 OR vend_id IN (1001, 1002);</div><div class="line">SELECT vend_id, prod_id, prod_price FROM products WHERE prod_price&lt;=5 UNION SELECT  vend_id, prod_id, prod_price FROM products WHERE vend_id IN (1001,1002) ORDER BY vend_id,prod_price;</div></pre></td></tr></table></figure>
<h4 id="全文本搜索"><a href="#全文本搜索" class="headerlink" title="全文本搜索"></a>全文本搜索</h4><ul>
<li>MyISAM引擎支持全文本搜索，InnoDB不支持</li>
<li>MATCH()指定被搜索的列</li>
<li>Against()指定要使用的搜索表达式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SELECT * FROM productnotes WHERE MATCH(note_text) Against(&apos;rabbit&apos;);</div><div class="line">SELECT * FROM productnotes WHERE note_text like &quot;%rabbit%&quot;;</div><div class="line">SELECT * FROM productnotes WHERE MATCH(note_text) Against(&apos;anvils&apos;);</div></pre></td></tr></table></figure>
<h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>视图是虚拟的表， 视图只包含使用时动态检索数据的查询</p>
<p>视图功能</p>
<pre><code>- 重用sql语句
- 简化复杂的sql操作
- 使用表的组成部分而不是整个表
- 保护数据
- 更改数据格式和表示 
</code></pre><p>基本语句</p>
<pre><code>- 创建使用 CREATE VIEW
- 查看创建视图的语句 SHOW CREATE VIEW viewname
- 删除视图， DROP VIEW viewname
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">SELECT cust_name, cust_contact FROM customers, orders, orderitems WHERE customers.cust_id = orders.cust_id AND </div><div class="line">orderitems.order_num = orders.order_num AND prod_id=&quot;TNT2&quot;;</div><div class="line">-- 创建视图</div><div class="line">CREATE VIEW productcustomers AS SELECT cust_name, cust_contact, prod_id FROM customers, orders, orderitems WHERE customers.cust_id=orders.cust_id AND</div><div class="line">orderitems.order_num = orders.order_num;</div><div class="line">SELECT cust_name, cust_contact FROM productcustomers;</div><div class="line">SELECT cust_name, cust_contact FROM productcustomers WHERE prod_id=&apos;TNT2&apos;;</div><div class="line">-- 重新格式化检索出的数据</div><div class="line">CREATE VIEW vendorlocations AS SELECT CONCAT(RTRIM(vend_name), &apos;(&apos;, RTRIM(vend_country), &apos;)&apos;) AS vend_title FROM vendors ORDER BY vend_name;</div><div class="line">SELECT * FROM vendorlocations;</div><div class="line">-- 视图过滤不想要的数据</div><div class="line">CREATE VIEW customeremiallist AS SELECT * FROM customers WHERE cust_email IS NOT NULL;</div><div class="line">SELECT * FROM customeremiallist;</div><div class="line">-- 使用视图与计算字段</div><div class="line">CREATE VIEW orderitemsexpanded AS SELECT order_num, prod_id, quantity, item_price, quantity*item_price AS expanded_price FROM orderitems;</div><div class="line">SELECT * FROM orderitemsexpanded WHERE order_num=20005;</div><div class="line">-- 查看视图</div><div class="line">SHOW CREATE VIEW orderitemsexpanded;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看了一下mysql基础知识， 主要集中在相关查询操作上，记录如下：&lt;/p&gt;
&lt;p&gt;其中使用的数据库结构和数据为&lt;a href=&quot;http://forta.com/books/0672327120/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http
    
    </summary>
    
      <category term="Mysql" scheme="https://ttxsgoto.github.io/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="https://ttxsgoto.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ</title>
    <link href="https://ttxsgoto.github.io/2018/08/25/rabbitmq/"/>
    <id>https://ttxsgoto.github.io/2018/08/25/rabbitmq/</id>
    <published>2018-08-25T07:22:15.000Z</published>
    <updated>2018-08-25T08:24:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近工作需要，需要使用到RabbitMQ，于是理解了一下相关概念和代码测试了一下，记录如下：</p>
<h4 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a>RabbitMQ简介</h4><p>AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。<br>AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。<br>RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持Ajax。</p>
<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>RabbitMQ中的消息都只能存储在Queue中，生产者（下图中的P）生产消息并最终投递到Queue中，消费者（下图中的C）可以从Queue中获取消息并消费。<br><img src="https://ttxsgoto.github.io/img/rabbitmq/01.png" alt=""><br>多个消费者可以订阅同一个Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。<br><img src="https://ttxsgoto.github.io/img/rabbitmq/02.png" alt=""></p>
<h4 id="Message-acknowledgment-确认机制"><a href="#Message-acknowledgment-确认机制" class="headerlink" title="Message acknowledgment(确认机制)"></a>Message acknowledgment(确认机制)</h4><p>在实际应用中，可能会发生消费者收到Queue中的消息，但没有处理完成就宕机（或出现其他意外）的情况，这种情况下就可能会导致消息丢失。为了避免这种情况发生，我们可以要求消费者在消费完消息后发送一个回执给RabbitMQ，RabbitMQ收到消息回执（Message acknowledgment）后才将该消息从Queue中移除；如果RabbitMQ没有收到回执并检测到消费者的RabbitMQ连接断开，则RabbitMQ会将该消息发送给其他消费者（如果存在多个消费者）进行处理。这里不存在timeout概念，一个消费者处理消息时间再长也不会导致该消息被发送给其他消费者，除非它的RabbitMQ连接断开。<br>这里会产生另外一个问题，如果我们的开发人员在处理完业务逻辑后，忘记发送回执给RabbitMQ，这将会导致严重的bug——Queue中堆积的消息会越来越多；消费者重启后会重复消费这些消息并重复执行业务逻辑,另外pub message是没有ack的。<br>rabbitmq_producer_ack.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"> </div><div class="line"><span class="keyword">import</span> pika</div><div class="line"> </div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">"127.0.0.1"</span>, port=<span class="number">5672</span>))</div><div class="line"> </div><div class="line"><span class="comment"># 创建一个频道</span></div><div class="line">channel = connection.channel()</div><div class="line"> </div><div class="line"><span class="comment"># 通过频道创建队列，如果有则忽略，没有则创建</span></div><div class="line">channel.queue_declare(queue=<span class="string">"ttxsgoto"</span>)</div><div class="line"> </div><div class="line"><span class="comment"># 设置指定队列名称，body往队列中发送消息</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</div><div class="line">    channel.basic_publish(exchange=<span class="string">''</span>,</div><div class="line">                          routing_key=<span class="string">"ttxsgoto"</span>,</div><div class="line">                          body=<span class="string">"Hello World!--&#123;&#125;"</span>.format(i))</div><div class="line">    print(<span class="string">"Sent 'Hello World!' - &#123;&#125; "</span>.format(i))</div><div class="line"> </div><div class="line">connection.close()</div></pre></td></tr></table></figure></p>
<p>rabbitmq_consumer_ack.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"> </div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> pika</div><div class="line"> </div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">"127.0.0.1"</span>, port=<span class="number">5672</span>))</div><div class="line"> </div><div class="line"><span class="comment"># 创建一个频道</span></div><div class="line">channel = connection.channel()</div><div class="line"> </div><div class="line"><span class="comment"># 通过频道创建队列，如果有则忽略，没有则创建</span></div><div class="line">channel.queue_declare(queue=<span class="string">"ttxsgoto"</span>)</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">"Received %s"</span> % body)</div><div class="line">    time.sleep(<span class="number">1</span>)</div><div class="line">    print(<span class="string">"ok"</span>)</div><div class="line">    ch.basic_ack(delivery_tag=method.delivery_tag)  <span class="comment"># 向生产者发送消费完毕的确认消息，然后生产者将该条消息从队列中剔除</span></div><div class="line"> </div><div class="line"> </div><div class="line"><span class="comment"># 从队列中取消息</span></div><div class="line">channel.basic_consume(callback,</div><div class="line">                      queue=<span class="string">"ttxsgoto"</span>,</div><div class="line">                      no_ack=<span class="keyword">False</span>)  <span class="comment"># 如果no_ack=False,当消费者down掉，rabbitmq会重新将该任务添加到队列中</span></div><div class="line"> </div><div class="line">print(<span class="string">"Waiting for messages,To exit press CTRL + C"</span>)</div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure></p>
<h4 id="Message-durability-持久化"><a href="#Message-durability-持久化" class="headerlink" title="Message durability(持久化)"></a>Message durability(持久化)</h4><p>如果我们希望即使在RabbitMQ服务重启的情况下，也不会丢失消息，我们可以将Queue与Message都设置为可持久化的（durable），这样可以保证绝大部分情况下我们的RabbitMQ消息不会丢失。<br>rabbitmq_producer_ack_durable.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"><span class="comment"># 消息队列是可以做持久化，如果我们在生产消息的时候就指定某条消息需要做持久化，那么RabbitMQ发现有问题时，就会将消息保存到硬盘，持久化下来</span></div><div class="line"><span class="comment"># 此时rabbitmq down掉时，再启动 队列和数据也都是存在的，如果不持久化，down掉后队列就没有了</span></div><div class="line"> </div><div class="line"><span class="keyword">import</span> pika</div><div class="line"> </div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">"127.0.0.1"</span>, port=<span class="number">5672</span>))</div><div class="line"> </div><div class="line"><span class="comment"># 创建一个频道</span></div><div class="line">channel = connection.channel()</div><div class="line"> </div><div class="line"><span class="comment"># 通过频道创建队列，如果有则忽略，没有则创建,指定队列持久化</span></div><div class="line">channel.queue_declare(queue=<span class="string">"ttxsgoto01"</span>, durable=<span class="keyword">True</span>)</div><div class="line"> </div><div class="line"><span class="comment"># 设置指定队列名称，body往队列中发送消息</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</div><div class="line">    channel.basic_publish(exchange=<span class="string">''</span>,</div><div class="line">                          routing_key=<span class="string">"ttxsgoto01"</span>,</div><div class="line">                          body=<span class="string">"Hello World!--&#123;&#125;"</span>.format(i),</div><div class="line">                          properties=pika.BasicProperties(delivery_mode=<span class="number">2</span>, ))  <span class="comment"># 指定消息持久化</span></div><div class="line">    print(<span class="string">"Sent 'Hello World!' - &#123;&#125; "</span>.format(i))</div><div class="line"> </div><div class="line"><span class="comment"># 关闭连接</span></div><div class="line">connection.close()</div></pre></td></tr></table></figure></p>
<p>rabbitmq_consumer_ack_durable.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"><span class="comment"># 消息队列是可以做持久化，如果我们在生产消息的时候就指定某条消息需要做持久化，那么RabbitMQ发现有问题时，就会将消息保存到硬盘，持久化下来</span></div><div class="line"> </div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> pika</div><div class="line"> </div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">"127.0.0.1"</span>, port=<span class="number">5672</span>))</div><div class="line"> </div><div class="line"><span class="comment"># 创建一个频道</span></div><div class="line">channel = connection.channel()</div><div class="line"> </div><div class="line"><span class="comment"># 通过频道创建队列，如果有则忽略，没有则创建,队列持久化</span></div><div class="line">channel.queue_declare(queue=<span class="string">"ttxsgoto01"</span>, durable=<span class="keyword">True</span>)</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">"Received %s"</span> % body)</div><div class="line">    time.sleep(<span class="number">1</span>)</div><div class="line">    print(<span class="string">"ok"</span>)</div><div class="line">    ch.basic_ack(delivery_tag=method.delivery_tag)  <span class="comment"># 向生产者发送消费完毕的确认消息，然后生产者将该条消息从队列中剔除</span></div><div class="line"> </div><div class="line"> </div><div class="line"><span class="comment"># 从队列中取消息</span></div><div class="line">channel.basic_consume(callback,</div><div class="line">                      queue=<span class="string">"ttxsgoto01"</span>,</div><div class="line">                      no_ack=<span class="keyword">False</span>)  <span class="comment"># 如果no_ack=False,当消费者down掉，rabbitmq会重新将该任务添加到队列中</span></div><div class="line"> </div><div class="line">print(<span class="string">"Waiting for messages,To exit press CTRL + C"</span>)</div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure></p>
<p>说明：消息队列是可以做持久化，如果我们在生产消息的时候就指定某条消息需要做持久化，那么RabbitMQ发现有问题时，就会将消息保存到硬盘，持久化下来；此时可以通过rabbitmq web管理页面看到队列ttxsgoto01的Parameters有一个D属性，表示durable=True</p>
<h4 id="Prefetch-count-每发送数"><a href="#Prefetch-count-每发送数" class="headerlink" title="Prefetch count(每发送数)"></a>Prefetch count(每发送数)</h4><p>如果有多个消费者同时订阅同一个Queue中的消息，Queue中的消息会被平摊给多个消费者。这时如果每个消息的处理时间不同，就有可能会导致某些消费者一直在忙，而另外一些消费者很快就处理完手头工作并一直空闲的情况。我们可以通过设置prefetchCount来限制Queue每次发送给每个消费者的消息数，比如我们设置prefetchCount=1，则Queue每次给每个消费者发送一条消息；消费者处理完这条消息后Queue会再给该消费者发送一条消息<br>rabbitmq_producer_ack_durable_qos.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"><span class="comment"># 消息队列是可以做持久化，如果我们在生产消息的时候就指定某条消息需要做持久化，那么RabbitMQ发现有问题时，就会将消息保存到硬盘，持久化下来</span></div><div class="line"><span class="comment"># 此时rabbitmq down掉时，再启动 队列和数据也都是存在的，如果不持久化，down掉后队列就没有了</span></div><div class="line"> </div><div class="line"><span class="keyword">import</span> pika</div><div class="line"> </div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">"127.0.0.1"</span>, port=<span class="number">5672</span>))</div><div class="line"> </div><div class="line"><span class="comment"># 创建一个频道</span></div><div class="line">channel = connection.channel()</div><div class="line"> </div><div class="line"><span class="comment"># 通过频道创建队列，如果有则忽略，没有则创建,指定队列持久化</span></div><div class="line">channel.queue_declare(queue=<span class="string">"ttxsgoto02"</span>, durable=<span class="keyword">True</span>)</div><div class="line"> </div><div class="line"><span class="comment"># 设置指定队列名称，body往队列中发送消息</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</div><div class="line">    channel.basic_publish(exchange=<span class="string">''</span>,</div><div class="line">                          routing_key=<span class="string">"ttxsgoto02"</span>,</div><div class="line">                          body=<span class="string">"Hello World!--&#123;&#125;"</span>.format(i),</div><div class="line">                          properties=pika.BasicProperties(delivery_mode=<span class="number">2</span>, ))  <span class="comment"># 指定消息持久化</span></div><div class="line">    print(<span class="string">"Sent 'Hello World!' - &#123;&#125; "</span>.format(i))</div><div class="line"> </div><div class="line"><span class="comment"># 关闭连接</span></div><div class="line">connection.close()</div></pre></td></tr></table></figure></p>
<p>rabbitmq_consumer_ack_durable_qos.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"> </div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> pika</div><div class="line"> </div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">"127.0.0.1"</span>, port=<span class="number">5672</span>))</div><div class="line"> </div><div class="line"><span class="comment"># 创建一个频道</span></div><div class="line">channel = connection.channel()</div><div class="line"> </div><div class="line"><span class="comment"># 通过频道创建队列，如果有则忽略，没有则创建,队列持久化</span></div><div class="line">channel.queue_declare(queue=<span class="string">"ttxsgoto02"</span>, durable=<span class="keyword">True</span>)</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">"Received %s"</span> % body)</div><div class="line">    time.sleep(<span class="number">1</span>)</div><div class="line">    print(<span class="string">"ok"</span>)</div><div class="line">    ch.basic_ack(delivery_tag=method.delivery_tag)  <span class="comment"># 向生产者发送消费完毕的确认消息，然后生产者将该条消息从队列中剔除</span></div><div class="line"> </div><div class="line"> </div><div class="line"><span class="comment"># 表示谁来获取，不再按照奇偶数排列</span></div><div class="line">channel.basic_qos(prefetch_count=<span class="number">1</span>)</div><div class="line"> </div><div class="line"><span class="comment"># 从队列中取消息</span></div><div class="line">channel.basic_consume(callback,</div><div class="line">                      queue=<span class="string">"ttxsgoto02"</span>,</div><div class="line">                      no_ack=<span class="keyword">False</span>)  <span class="comment"># 如果no_ack=False,当消费者down掉，rabbitmq会重新将该任务添加到队列中</span></div><div class="line"> </div><div class="line">print(<span class="string">"Waiting for messages,To exit press CTRL + C"</span>)</div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure></p>
<h4 id="Exchange-交换器"><a href="#Exchange-交换器" class="headerlink" title="Exchange(交换器)"></a>Exchange(交换器)</h4><p>在上一节我们看到生产者将消息投递到Queue中，实际上这在RabbitMQ中这种事情永远都不会发生。实际的情况是，生产者将消息发送到Exchange（交换器，下图中的X），由Exchange将消息路由到一个或多个Queue中（或者丢弃）。<br><img src="https://ttxsgoto.github.io/img/rabbitmq/03.png" alt=""></p>
<h4 id="routing-key"><a href="#routing-key" class="headerlink" title="routing key"></a>routing key</h4><p>生产者在将消息发送给Exchange的时候，一般会指定一个routing key，来指定这个消息的路由规则，而这个routing key需要与Exchange Type及binding key联合使用才能最终生效。（routing key + exchange type + binding key）<br>在Exchange Type与binding key固定的情况下（在正常使用时一般这些内容都是固定配置好的），我们的生产者就可以在发送消息给Exchange时，通过指定routing key来决定消息流向哪里。<br>RabbitMQ为routing key设定的长度限制为255 bytes</p>
<h4 id="Binding-绑定到Queue"><a href="#Binding-绑定到Queue" class="headerlink" title="Binding(绑定到Queue)"></a>Binding(绑定到Queue)</h4><p>RabbitMQ中通过Binding将Exchange与Queue关联起来，这样RabbitMQ就知道如何正确地将消息路由到指定的Queue了。<br><img src="https://ttxsgoto.github.io/img/rabbitmq/04.png" alt=""></p>
<h4 id="Binding-key"><a href="#Binding-key" class="headerlink" title="Binding key"></a>Binding key</h4><p>在绑定（Binding）Exchange与Queue的同时，一般会指定一个binding key；消费者将消息发送给Exchange时，一般会指定一个routing key；当binding key与routing key相匹配时，消息将会被路由到对应的Queue中。<br>在绑定多个Queue到同一个Exchange的时候，这些Binding允许使用相同的binding key。<br>binding key 并不是在所有情况下都生效，它依赖于Exchange Type，比如fanout类型的Exchange就会无视binding key，而是将消息路由到所有绑定到该Exchange的Queue。</p>
<h4 id="Exchange-Types"><a href="#Exchange-Types" class="headerlink" title="Exchange Types"></a>Exchange Types</h4><p>RabbitMQ常用的Exchange Type有fanout、direct、topic、headers这四种,一般headers使用较少，不做演示说明，下面分别进行介绍</p>
<h5 id="fanout"><a href="#fanout" class="headerlink" title="fanout"></a>fanout</h5><p>fanout类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中。<br><img src="https://ttxsgoto.github.io/img/rabbitmq/05.png" alt=""><br>上图中，生产者（P）发送到Exchange（X）的所有消息都会路由到图中的两个Queue，并最终被两个消费者（C1与C2）消费。<br>rabbitmq_producer_fanout.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"><span class="comment"># exchange type = fanout ：任何发送到Fanout Exchange的消息都会被转发到与该Exchange绑定(Binding)的所有Queue上</span></div><div class="line"> </div><div class="line"><span class="keyword">import</span> pika</div><div class="line"> </div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">5672</span>))</div><div class="line"> </div><div class="line"><span class="comment"># 创建一个频道</span></div><div class="line">channel = connection.channel()</div><div class="line"> </div><div class="line"><span class="comment"># 指定exchange和对应的类型</span></div><div class="line">channel.exchange_declare(exchange=<span class="string">"test_fanout"</span>,</div><div class="line">                         exchange_type=<span class="string">'fanout'</span>)</div><div class="line"> </div><div class="line"><span class="comment"># 设置exchange，没有指定routing_key，队列随机</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</div><div class="line">    channel.basic_publish(exchange=<span class="string">'test_fanout'</span>,</div><div class="line">                          routing_key=<span class="string">"abc"</span>,</div><div class="line">                          body=<span class="string">"Hello World!--&#123;&#125;"</span>.format(i),</div><div class="line">                          properties=pika.BasicProperties(delivery_mode=<span class="number">2</span>, ))  <span class="comment"># 指定消息持久化</span></div><div class="line">    print(<span class="string">"Sent 'Hello World!' - &#123;&#125; "</span>.format(i))</div><div class="line"> </div><div class="line"><span class="comment"># 关闭连接</span></div><div class="line">connection.close()</div></pre></td></tr></table></figure></p>
<p>rabbitmq_consumer_fanout.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"><span class="comment"># exchange type = fanout ：任何发送到Fanout Exchange的消息都会被转发到与该Exchange绑定(Binding)的所有Queue上</span></div><div class="line"> </div><div class="line"><span class="keyword">import</span> pika</div><div class="line"><span class="keyword">import</span> time</div><div class="line"> </div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">"127.0.0.1"</span>, port=<span class="number">5672</span>))</div><div class="line"> </div><div class="line"><span class="comment"># 创建一个频道</span></div><div class="line">channel = connection.channel()</div><div class="line"> </div><div class="line">channel.exchange_declare(exchange=<span class="string">"test_fanout"</span>,  <span class="comment"># 创建一个exchange</span></div><div class="line">                         exchange_type=<span class="string">"fanout"</span>)  <span class="comment"># 任何发送到fanout exchange的消息都会被转发到和exchange绑定的queue上</span></div><div class="line"> </div><div class="line"><span class="comment"># 随机创建队列</span></div><div class="line">result = channel.queue_declare(exclusive=<span class="keyword">True</span>)</div><div class="line">queue_name = result.method.queue</div><div class="line"> </div><div class="line"><span class="comment"># 绑定，exchange绑定后端队列</span></div><div class="line">channel.queue_bind(exchange=<span class="string">"test_fanout"</span>,</div><div class="line">                   queue=queue_name)</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">"Received %s"</span> % body)</div><div class="line">    time.sleep(<span class="number">1</span>)</div><div class="line">    <span class="comment"># ch.basic_ack(delivery_tag=method.delivery_tag)  # 向生产者发送消费完毕的确认消息，然后生产者将该条消息从队列中剔除</span></div><div class="line"> </div><div class="line"> </div><div class="line"><span class="comment"># 从队列中取消息</span></div><div class="line">channel.basic_consume(callback,</div><div class="line">                      queue=queue_name,</div><div class="line">                      no_ack=<span class="keyword">True</span>)  <span class="comment"># 如果no_ack=False,当消费者down掉，rabbitmq会重新将该任务添加到队列中</span></div><div class="line"> </div><div class="line">print(<span class="string">"Waiting for messages,To exit press CTRL + C"</span>)</div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure></p>
<h5 id="direct"><a href="#direct" class="headerlink" title="direct"></a>direct</h5><p>direct类型的Exchange路由规则也很简单，它会把消息路由到那些binding key与routing key完全匹配的Queue中。<br><img src="https://ttxsgoto.github.io/img/rabbitmq/06.png" alt=""><br>以上图的配置为例，我们以routingKey=”error”发送消息到Exchange，则消息会路由到Queue1（amqp.gen-S9b…，这是由RabbitMQ自动生成的Queue名称）和Queue2（amqp.gen-Agl…）；如果我们以routingKey=”info”或routingKey=”warning”来发送消息，则消息只会路由到Queue2。如果我们以其他routingKey发送消息，则消息不会路由到这两个Queue中。<br>rabbitmq_producer_direct.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"><span class="comment"># exchange type = direct：任何发送到Direct Exchange的消息都会被转发到RouteKey中指定的Queue上(关键字发送)</span></div><div class="line"><span class="comment"># 队列绑定关键字，发送者将数据关键字发送到消息Exchange，Exchange根据关键字判定应该将数据发送至指定队列</span></div><div class="line"><span class="comment"># 结论：当我们将发布者的key设置成Error的时候两个队列对可以收到Exchange的消息，当我们将key设置成info后，只有订阅者1可以收到Exchange的消息</span></div><div class="line"> </div><div class="line"><span class="keyword">import</span> pika</div><div class="line"> </div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">"127.0.0.1"</span>, port=<span class="number">5672</span>))</div><div class="line"> </div><div class="line"><span class="comment"># 创建一个频道</span></div><div class="line">channel = connection.channel()</div><div class="line"> </div><div class="line"><span class="comment"># 指定exchange和对应的类型</span></div><div class="line">channel.exchange_declare(exchange=<span class="string">"test_direct"</span>,</div><div class="line">                         exchange_type=<span class="string">'direct'</span>)</div><div class="line">typeinfo = <span class="string">'info'</span></div><div class="line"> </div><div class="line"><span class="comment"># 设置exchange，没有指定routing_key，队列指定关键字</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</div><div class="line">    channel.basic_publish(exchange=<span class="string">'test_direct'</span>,</div><div class="line">                          routing_key=typeinfo,</div><div class="line">                          body=<span class="string">"Hello World!--&#123;&#125;"</span>.format(i),</div><div class="line">                          properties=pika.BasicProperties(delivery_mode=<span class="number">2</span>, ))  <span class="comment"># 指定消息持久化</span></div><div class="line">    print(<span class="string">"Sent 'Hello World!' - &#123;&#125; "</span>.format(i))</div><div class="line"> </div><div class="line"><span class="comment"># 关闭连接</span></div><div class="line">connection.close()</div></pre></td></tr></table></figure></p>
<p>rabbitmq_consumer_direct1.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"><span class="comment"># exchange type = direct：任何发送到Direct Exchange的消息都会被转发到RouteKey中指定的Queue上(关键字发送)</span></div><div class="line"><span class="comment"># 队列绑定关键字，发送者将数据关键字发送到消息Exchange，Exchange根据关键字判定应该将数据发送至指定队列</span></div><div class="line"> </div><div class="line"><span class="keyword">import</span> pika</div><div class="line"><span class="keyword">import</span> time</div><div class="line"> </div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">"127.0.0.1"</span>, port=<span class="number">5672</span>))</div><div class="line"> </div><div class="line"><span class="comment"># 创建一个频道</span></div><div class="line">channel = connection.channel()</div><div class="line">channel.exchange_declare(exchange=<span class="string">"test_direct"</span>,  <span class="comment"># 创建一个exchange</span></div><div class="line">                         exchange_type=<span class="string">"direct"</span>)</div><div class="line"><span class="comment"># 随机创建队列</span></div><div class="line">result = channel.queue_declare(exclusive=<span class="keyword">True</span>)</div><div class="line">queue_name = result.method.queue</div><div class="line"> </div><div class="line">typeinfo = [<span class="string">'error'</span>, <span class="string">'info'</span>, ]</div><div class="line"> </div><div class="line"><span class="comment"># 绑定，exchange绑定后端队列</span></div><div class="line"><span class="keyword">for</span> type1 <span class="keyword">in</span> typeinfo:</div><div class="line">    channel.queue_bind(exchange=<span class="string">"test_direct"</span>, queue=queue_name, routing_key=type1)</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">"Received %s --- %s"</span> % (method.routing_key, body))</div><div class="line">    time.sleep(<span class="number">1</span>)</div><div class="line">    <span class="comment"># ch.basic_ack(delivery_tag=method.delivery_tag)  # 向生产者发送消费完毕的确认消息，然后生产者将该条消息从队列中剔除</span></div><div class="line"> </div><div class="line"> </div><div class="line"><span class="comment"># 从队列中取消息</span></div><div class="line">channel.basic_consume(callback,</div><div class="line">                      queue=queue_name,</div><div class="line">                      no_ack=<span class="keyword">True</span>)  <span class="comment"># 如果no_ack=False,当消费者down掉，rabbitmq会重新将该任务添加到队列中</span></div><div class="line"> </div><div class="line">print(<span class="string">"Waiting for messages,To exit press CTRL + C"</span>)</div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure></p>
<p>rabbitmq_consumer_direct2.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"><span class="comment"># exchange type = direct：任何发送到Direct Exchange的消息都会被转发到RouteKey中指定的Queue上(关键字发送)</span></div><div class="line"><span class="comment"># 队列绑定关键字，发送者将数据关键字发送到消息Exchange，Exchange根据关键字判定应该将数据发送至指定队列</span></div><div class="line"> </div><div class="line"><span class="keyword">import</span> pika</div><div class="line"><span class="keyword">import</span> time</div><div class="line"> </div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">"127.0.0.1"</span>, port=<span class="number">5672</span>))</div><div class="line"> </div><div class="line"><span class="comment"># 创建一个频道</span></div><div class="line">channel = connection.channel()</div><div class="line">channel.exchange_declare(exchange=<span class="string">"test_direct"</span>,  <span class="comment"># 创建一个exchange</span></div><div class="line">                         exchange_type=<span class="string">"direct"</span>)</div><div class="line"><span class="comment"># 随机创建队列</span></div><div class="line">result = channel.queue_declare(exclusive=<span class="keyword">True</span>)</div><div class="line">queue_name = result.method.queue</div><div class="line"> </div><div class="line">typeinfo = [<span class="string">'error'</span>, ]</div><div class="line"> </div><div class="line"><span class="comment"># 绑定，exchange绑定后端队列</span></div><div class="line"><span class="keyword">for</span> type1 <span class="keyword">in</span> typeinfo:</div><div class="line">    channel.queue_bind(exchange=<span class="string">"test_direct"</span>, queue=queue_name, routing_key=type1)</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">"Received %s --- %s"</span> % (method.routing_key, body))</div><div class="line">    time.sleep(<span class="number">1</span>)</div><div class="line">    <span class="comment"># ch.basic_ack(delivery_tag=method.delivery_tag)  # 向生产者发送消费完毕的确认消息，然后生产者将该条消息从队列中剔除</span></div><div class="line"> </div><div class="line"> </div><div class="line"><span class="comment"># 从队列中取消息</span></div><div class="line">channel.basic_consume(callback,</div><div class="line">                      queue=queue_name,</div><div class="line">                      no_ack=<span class="keyword">True</span>)  <span class="comment"># 如果no_ack=False,当消费者down掉，rabbitmq会重新将该任务添加到队列中</span></div><div class="line"> </div><div class="line">print(<span class="string">"Waiting for messages,To exit press CTRL + C"</span>)</div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure></p>
<p>结论：当我们将发布者的key设置成error的时候两个队列对可以收到Exchange的消息，当我们将key设置成info后，只有订阅者1可以收到Exchange的消息。</p>
<h5 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h5><p>direct类型的Exchange路由规则是完全匹配binding key与routing key，但这种严格的匹配方式在很多情况下不能满足实际业务需求。topic类型的Exchange在匹配规则上进行了扩展，它与direct类型的Exchage相似，也是将消息路由到binding key与routing key相匹配的Queue中，但这里的匹配规则有些不同，它约定：</p>
<ul>
<li><p>routing key为一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词），如“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit”</p>
</li>
<li><p>binding key与routing key一样也是句点号“. ”分隔的字符串</p>
</li>
<li><p>binding key中可以存在两种特殊字符“<em>”与“#”，用于做模糊匹配，其中“</em>”用于匹配一个单词，“#”用于匹配多个单词（可以是零个）</p>
</li>
</ul>
<p><img src="https://ttxsgoto.github.io/img/rabbitmq/07.png" alt=""></p>
<p>以上图中的配置为例，routingKey=”quick.orange.rabbit”的消息会同时路由到Q1与Q2，routingKey=”lazy.orange.fox”的消息会路由到Q1，routingKey=”lazy.brown.fox”的消息会路由到Q2，routingKey=”lazy.pink.rabbit”的消息会路由到Q2（只会投递给Q2一次，虽然这个routingKey与Q2的两个bindingKey都匹配）；routingKey=”quick.brown.fox”、routingKey=”orange”、routingKey=”quick.orange.male.rabbit”的消息将会被丢弃，因为它们没有匹配任何bindingKey。<br>rabbitmq_producer_topic.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"><span class="comment"># exchange type = topic：任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上(模糊匹配)</span></div><div class="line"><span class="comment"># 在topic类型下，可以让队列绑定几个模糊的关键字，之后发送者将数据发送到exchange，exchange将传入"路由值"和"关键字"进行匹配，匹配成功，则将数据发送到指定队列</span></div><div class="line"><span class="comment"># # ：表示可以匹配0个或多个单词</span></div><div class="line"><span class="comment"># * ：表示只能匹配一个单词</span></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> pika</div><div class="line"> </div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">"127.0.0.1"</span>, port=<span class="number">5672</span>))</div><div class="line"> </div><div class="line"><span class="comment"># 创建一个频道</span></div><div class="line">channel = connection.channel()</div><div class="line"> </div><div class="line"><span class="comment"># 指定exchange和对应的类型</span></div><div class="line">channel.exchange_declare(exchange=<span class="string">"test_topic"</span>,</div><div class="line">                         exchange_type=<span class="string">'topic'</span>)</div><div class="line"> </div><div class="line">routing_key = sys.argv[<span class="number">1</span>] <span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="string">'anonymous'</span></div><div class="line">message = <span class="string">''</span>.join(sys.argv[<span class="number">2</span>:]) <span class="keyword">or</span> <span class="string">'Hello Chengdu!'</span></div><div class="line"> </div><div class="line"><span class="comment"># 设置exchange，没有指定routing_key，队列指定关键字</span></div><div class="line">channel.basic_publish(exchange=<span class="string">'test_topic'</span>, routing_key=routing_key, body=message)</div><div class="line"> </div><div class="line">print(<span class="string">" Sent routing_key:%s ——&gt; body:%s "</span> % (routing_key, message))</div><div class="line"><span class="comment"># 关闭连接</span></div><div class="line">connection.close()</div></pre></td></tr></table></figure></p>
<p>rabbitmq_consumer_topic.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># coding: utf-8</span></div><div class="line"><span class="comment"># exchange type = topic：任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上(模糊匹配)</span></div><div class="line"><span class="comment"># 在topic类型下，可以让队列绑定几个模糊的关键字，之后发送者将数据发送到exchange，exchange将传入"路由值"和"关键字"进行匹配，匹配成功，则将数据发送到指定队列</span></div><div class="line"> </div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> pika</div><div class="line"> </div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">"127.0.0.1"</span>, port=<span class="number">5672</span>))</div><div class="line"> </div><div class="line"><span class="comment"># 创建一个频道</span></div><div class="line">channel = connection.channel()</div><div class="line"> </div><div class="line"><span class="comment"># 创建一个exchange,并指定类型</span></div><div class="line">channel.exchange_declare(exchange=<span class="string">"test_topic"</span>,</div><div class="line">                         exchange_type=<span class="string">"topic"</span>)</div><div class="line"><span class="comment"># 随机创建队列</span></div><div class="line">result = channel.queue_declare(exclusive=<span class="keyword">True</span>)</div><div class="line"> </div><div class="line">queue_name = result.method.queue</div><div class="line">binding_keys = sys.argv[<span class="number">1</span>:]</div><div class="line"> </div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> binding_keys:</div><div class="line">    sys.stderr.write(<span class="string">"Usage: %s [binding_key]...\n"</span> % sys.argv[<span class="number">0</span>])</div><div class="line">    sys.exit(<span class="number">0</span>)</div><div class="line"> </div><div class="line"><span class="keyword">for</span> binding_key <span class="keyword">in</span> binding_keys:</div><div class="line">    channel.queue_bind(exchange=<span class="string">"test_topic"</span>, queue=queue_name, routing_key=binding_key)</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">"Received %s -----%s "</span> % (method.routing_key, body))</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="comment"># 从队列中取消息</span></div><div class="line">channel.basic_consume(callback,</div><div class="line">                      queue=queue_name,</div><div class="line">                      no_ack=<span class="keyword">True</span>)  <span class="comment"># 如果no_ack=False,当消费者down掉，rabbitmq会重新将该任务添加到队列中</span></div><div class="line"> </div><div class="line">print(<span class="string">"Waiting for messages,To exit press CTRL + C"</span>)</div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure></p>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">添加用户：</div><div class="line">rabbitmqctl add_user abc abc</div><div class="line"> </div><div class="line">添加权限：</div><div class="line">rabbitmqctl set_permissions -p &quot;/&quot; abc &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</div><div class="line"> </div><div class="line">设置用户标签：</div><div class="line">rabbitmqctl set_user_tags abc administrator</div><div class="line"> </div><div class="line">删除用户：</div><div class="line">rabbitmqctl delete_user guest</div><div class="line"> </div><div class="line">修改密码：</div><div class="line">rabbitmqctl change_password   username  newpassword</div><div class="line"> </div><div class="line">list_users</div><div class="line">add_vhost   vhostpath</div><div class="line">rabbitmqctl list_user_permissions abc  </div><div class="line">list_queues </div><div class="line">list_exchanges</div><div class="line">list_bindings</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近工作需要，需要使用到RabbitMQ，于是理解了一下相关概念和代码测试了一下，记录如下：&lt;/p&gt;
&lt;h4 id=&quot;RabbitMQ简介&quot;&gt;&lt;a href=&quot;#RabbitMQ简介&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ简介&quot;&gt;&lt;/a&gt;Ra
    
    </summary>
    
      <category term="中间件" scheme="https://ttxsgoto.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="RabbitMQ" scheme="https://ttxsgoto.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Mysql索引02</title>
    <link href="https://ttxsgoto.github.io/2018/08/11/yw-mysql-index02/"/>
    <id>https://ttxsgoto.github.io/2018/08/11/yw-mysql-index02/</id>
    <published>2018-08-11T03:33:20.000Z</published>
    <updated>2018-12-26T07:21:02.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="索引常见模型"><a href="#索引常见模型" class="headerlink" title="索引常见模型"></a>索引常见模型</h4><ul>
<li>哈希表<ul>
<li>适用于只有等值查询的场景</li>
<li>哈希冲突的处理办法：链表</li>
</ul>
</li>
<li>有序数组<ul>
<li>在等值查询和范围查询场景中性能都非常优秀</li>
<li>只适用于静态存储引擎</li>
<li>在更新数据时，需要挪动后面所有的记录，成本高</li>
</ul>
</li>
<li>搜索树</li>
</ul>
<h4 id="InnoDB索引模型"><a href="#InnoDB索引模型" class="headerlink" title="InnoDB索引模型"></a>InnoDB索引模型</h4><p>在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表</p>
<p>每一个索引在InnoDB里面对应一棵B+树</p>
<p>主键索引的叶子节点存的整行数据，主键索引也称为聚簇索引(clustered index)</p>
<p>非主键索引的叶子节点内容是主键的值，非主键索引也被称为二级索引(secondary index)</p>
<h4 id="主键索引和普通索引的查询区别"><a href="#主键索引和普通索引的查询区别" class="headerlink" title="主键索引和普通索引的查询区别"></a>主键索引和普通索引的查询区别</h4><ul>
<li>基于非主键索引的查询需要多扫描一棵索引数，扫描主键索引</li>
<li>回到主键索引树搜索的过程，我们称为回表</li>
</ul>
<h4 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h4><p>在插入数据时，索引的数据也会变化</p>
<p>如果插入的数据对应的数据页已经满了，根据B+树的算法，需要申请一个新的数据页，然后挪动部分数据到新的数据页中，该过程称为页分裂</p>
<p>页分裂影响性能而且也影响数据页的利用率</p>
<p>主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也越小</p>
<p>从性能和存储空间考虑，自增主键比没有使用自增主键合理</p>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>select id from table where k between 3 and 5;<br>索引K 已经“覆盖了”我们查询需求，我们称之为覆盖索引<br>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引为一个常用的性能优化手段</p>
<p>实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE `tuser` (</div><div class="line">    `id` int(11) NOT NULL,</div><div class="line">    `id_card` varchar(32) DEFAULT NULL,</div><div class="line">    `name` varchar(32) DEFAULT NULL,</div><div class="line">    `age` int(11) DEFAULT NULL,</div><div class="line">    `ismale` tinyint(1) DEFAULT NULL,</div><div class="line">    PRIMARY KEY (`id`),</div><div class="line">    KEY `id_card` (`id_card`),</div><div class="line">    KEY `name_age` (`name`,`age`)</div><div class="line">    ) ENGINE=InnoDB;</div></pre></td></tr></table></figure></p>
<p>如果现在有一个高频请求，要根据市民的身份证号查询他的姓名和年龄，这个联合索引就有意义了。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间</p>
<h4 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h4><ul>
<li>B+树这种索引结构，可利用索引的“最左前缀”，来定位记录</li>
<li>最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符</li>
<li>最左前缀评估标准，索引的复用能力</li>
</ul>
<p>建立联合索引时，如果安排索引内的字段顺序？</p>
<ul>
<li>如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的</li>
<li>在联合索引时，建立单个索引考虑的原则为空间</li>
</ul>
<h4 id="索引下推-Mysql5-6之后"><a href="#索引下推-Mysql5-6之后" class="headerlink" title="索引下推(Mysql5.6之后)"></a>索引下推(Mysql5.6之后)</h4><p>在索引遍历的过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数<br>name like “zhang%” and age&gt;10,会对匹配的数据进行回表查询，如果有索引下推机制，那么会先过滤掉age&lt;10的数据，在执行回表查询，提高检索速度</p>
<p>alter table T engine=InnoDB 是用来释放 delete 操作引起的页的空洞,也就是碎片空间 操作时候尽量避免当前表的dml 操作.<br>表数据很大情况 建议使用 Percona Toolkit 工具来执行</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;索引常见模型&quot;&gt;&lt;a href=&quot;#索引常见模型&quot; class=&quot;headerlink&quot; title=&quot;索引常见模型&quot;&gt;&lt;/a&gt;索引常见模型&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;哈希表&lt;ul&gt;
&lt;li&gt;适用于只有等值查询的场景&lt;/li&gt;
&lt;li&gt;哈希冲突的处理办法：链表&lt;/
    
    </summary>
    
      <category term="Mysql" scheme="https://ttxsgoto.github.io/categories/Mysql/"/>
    
    
      <category term="Index" scheme="https://ttxsgoto.github.io/tags/Index/"/>
    
  </entry>
  
  <entry>
    <title>asyncio 基本用法</title>
    <link href="https://ttxsgoto.github.io/2018/08/10/python-asyncio-basic/"/>
    <id>https://ttxsgoto.github.io/2018/08/10/python-asyncio-basic/</id>
    <published>2018-08-10T03:58:11.000Z</published>
    <updated>2018-08-10T09:39:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><p>同时开启多个任务，但一次只执行一个，当执行的任务遇到阻塞，就切换到下一个任务继续执行，<br>以期节省阻塞所占用的时间</p>
<p>要实现异步处理，需要有挂起的操作，当一个任务需要等待 IO 结果的时候，可以挂起当前任务，转而去执行其他任务</p>
<ol>
<li>event_loop： 事件循环，把一些函数注册到这个事件循环中，当条件满足时，就执行对应的方法</li>
<li>coroutine： 协程，可以看做一个协程对象类型，把协程对象注册到事件循环中，满足条件时被调用； async关键字来定义一个方法，这个方法在调用时不会立刻执行，而是返回一个协程对象</li>
<li>task： 任务，它是对协程对象的进一步封装，包含了任务的各个状态</li>
<li>future： 代表即将执行或者还没有执行的任务的结果，可以等同与task</li>
<li>async： 用于定义协程， 协程函数不能直接调用，直接调用协程函数得到的是协程对象(<coroutine object="" execute="" at="" 0x10359c938="">)</coroutine></li>
<li>await：用来将阻塞方法进行挂起</li>
</ol>
<h4 id="await-后的对象必须为如下的格式"><a href="#await-后的对象必须为如下的格式" class="headerlink" title="await 后的对象必须为如下的格式"></a>await 后的对象必须为如下的格式</h4><ul>
<li>原生的coroutine对象</li>
<li>一个由types.coroutine()修饰的生成器，这个生成器可以返回 coroutine 对象</li>
<li>一个包含 __await 方法的对象返回的一个迭代器。</li>
</ul>
<h4 id="asyncio模块实例"><a href="#asyncio模块实例" class="headerlink" title="asyncio模块实例"></a>asyncio模块实例</h4><h5 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"> </div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'No. '</span>, x)</div><div class="line"> </div><div class="line">coroutine = execute(<span class="number">2</span>)</div><div class="line"> </div><div class="line">print(<span class="string">'Coroutine--&gt;'</span>, coroutine)    <span class="comment"># 协程对象</span></div><div class="line">print(<span class="string">'After calling execute'</span>)</div><div class="line"> </div><div class="line"><span class="comment"># 创建事件循环</span></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line"> </div><div class="line"><span class="comment"># 方法一:将coroutine封装成task对象</span></div><div class="line"><span class="comment"># task = loop.create_task(coroutine)</span></div><div class="line"><span class="comment"># 方法二:通过 asyncio 的 ensure_future() 方法, 将coroutine封装成task对象,这样可以不借助于loop来定义,</span></div><div class="line"><span class="comment">#即使没有声明loop也可以提前定义好task对象</span></div><div class="line">task = asyncio.ensure_future(coroutine)</div><div class="line">task.add_done_callback(callback)    <span class="comment"># task添加回调函数(通过task.result()获取返回值)</span></div><div class="line"> </div><div class="line">print(<span class="string">'Task:'</span>, task)  <span class="comment"># 查看任务task的状态</span></div><div class="line"><span class="comment"># Task: &lt;Task pending coro=&lt;execute() ...</span></div><div class="line"><span class="comment"># 将协程对象注册到事件循环中</span></div><div class="line">loop.run_until_complete(task)</div><div class="line"> </div><div class="line">print(<span class="string">'Task:'</span>, task)</div><div class="line"><span class="comment"># Task: &lt;Task finished coro=&lt;execute() done ...</span></div><div class="line">print(<span class="string">'Task result: '</span>, task.result()) <span class="comment"># task在fiinished状态时,直接读取task的result方法，得到返回值</span></div><div class="line"><span class="comment"># loop.run_until_complete(coroutine)</span></div><div class="line">print(<span class="string">'After calling loop'</span>)</div></pre></td></tr></table></figure>
<h5 id="多任务执行"><a href="#多任务执行" class="headerlink" title="多任务执行"></a>多任务执行</h5><p>定义一个task列表，然后使用asyncio的wait()方法即可执行<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">import</span> requests</div><div class="line"> </div><div class="line">now = time.time()</div><div class="line"> </div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">num</span><span class="params">(number)</span>:</span></div><div class="line">    <span class="keyword">await</span> asyncio.sleep(number)</div><div class="line">    <span class="keyword">return</span> number</div><div class="line"> </div><div class="line">tasks = [asyncio.ensure_future(num(i)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</div><div class="line">print(<span class="string">'Tasks-'</span>, tasks)</div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">loop.run_until_complete(asyncio.wait(tasks))    <span class="comment"># asyncio.wait()用于执行tasks</span></div><div class="line">print(<span class="string">'Tasks-'</span>, tasks)</div><div class="line"><span class="keyword">for</span> task <span class="keyword">in</span> tasks:</div><div class="line">    print(<span class="string">'Task Result: '</span>, task.result())</div><div class="line"> </div><div class="line">print(<span class="string">'time--&gt;'</span>, time.time() - now)</div></pre></td></tr></table></figure></p>
<h5 id="协程嵌套"><a href="#协程嵌套" class="headerlink" title="协程嵌套"></a>协程嵌套</h5><p>即一个协程中await了另外一个协程<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">import</span> time</div><div class="line"> </div><div class="line">now = time.time()</div><div class="line"> </div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">num</span><span class="params">(number)</span>:</span></div><div class="line">    <span class="keyword">await</span> asyncio.sleep(number)</div><div class="line">    <span class="keyword">return</span> number</div><div class="line"> </div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    tasks = [asyncio.ensure_future(num(i)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)]</div><div class="line"></div><div class="line">    <span class="comment"># _tasks = await asyncio.gather(*tasks) #  asyncio.gather创建协程对象,await的返回值就是协程运行的结果</span></div><div class="line">    _tasks, pending = <span class="keyword">await</span> asyncio.wait(tasks) <span class="comment"># asyncio.wait挂起协程,Returns two sets of Future: (done, pending).</span></div><div class="line">    print(<span class="string">'-----'</span>, _tasks )</div><div class="line"></div><div class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> _tasks: <span class="comment"># 在函数里面返回结果</span></div><div class="line">        print((<span class="string">'wait result task-&gt;'</span>, task.result()))</div><div class="line">        print(<span class="string">'gather result task-&gt;'</span>, task)</div><div class="line">    <span class="keyword">return</span> _tasks</div><div class="line"> </div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">results = loop.run_until_complete(main())</div><div class="line"> </div><div class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</div><div class="line">    print((<span class="string">'wait result task-&gt;'</span>, result.result()))</div><div class="line">    <span class="comment"># print('gather result task-&gt;', result)</span></div><div class="line"> </div><div class="line">print(<span class="string">'TIME:'</span>, time.time() - now)</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;async-await&quot;&gt;&lt;a href=&quot;#async-await&quot; class=&quot;headerlink&quot; title=&quot;async/await&quot;&gt;&lt;/a&gt;async/await&lt;/h3&gt;&lt;h4 id=&quot;协程&quot;&gt;&lt;a href=&quot;#协程&quot; class=&quot;head
    
    </summary>
    
      <category term="python" scheme="https://ttxsgoto.github.io/categories/python/"/>
    
    
      <category term="asyncio" scheme="https://ttxsgoto.github.io/tags/asyncio/"/>
    
  </entry>
  
  <entry>
    <title>Mysql索引01</title>
    <link href="https://ttxsgoto.github.io/2018/04/15/yw-mysql-index/"/>
    <id>https://ttxsgoto.github.io/2018/04/15/yw-mysql-index/</id>
    <published>2018-04-15T14:34:24.000Z</published>
    <updated>2018-12-21T03:34:32.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><p>B-Tree索引：mysql引擎默认支持这种索引</p>
<p>MyISAM 使用前缀技术使索引更小<br>InnoDB 按照原数据格式进行存储</p>
<p>B-Tree索引可以快速访问数据，不再需要进行全表扫描获取需要的数据，从索引的根节点开始进行搜索</p>
<h4 id="Mysql索引原理"><a href="#Mysql索引原理" class="headerlink" title="Mysql索引原理"></a>Mysql索引原理</h4><h5 id="b-树介绍"><a href="#b-树介绍" class="headerlink" title="b+树介绍"></a>b+树介绍</h5><p><img src="https://ttxsgoto.github.io/img/mysql/btree_index.png" alt=""><br>如上图，是一颗b+树。浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含<br>几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。</p>
<p>真实的数据存在于叶子节点，即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中</p>
<h5 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h5><p>在上图中，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高</p>
<h5 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h5><p>(1) 索引字段要尽量的小。</p>
<p>通过上面b+树的查找过程，或者通过真实的数据存在于叶子节点这个事实可知，IO次数取决于b+数的高度h。</p>
<p>假设当前数据表的数据量为N，每个磁盘块的数据项的数量是m，则树高h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；</p>
<p>而m = 磁盘块的大小/数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的；如果数据项占的空间越小，数据项的数量m越多，树的高度h越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。</p>
<p>(2) 索引的最左匹配特性</p>
<p>当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</p>
<h4 id="Mysql索引类型"><a href="#Mysql索引类型" class="headerlink" title="Mysql索引类型"></a>Mysql索引类型</h4><ul>
<li><p>主键索引 PRIMARY KEY</p>
<p>  它是一种特殊的唯一索引，不允许有空值,一般是在建表的时候同时创建主键索引</p>
</li>
<li><p>唯一索引 UNIQUE</p>
<p>  唯一索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。可以在创建表的时候指定，也可以修改表结构，如：<br>  ALTER TABLE table_name ADD UNIQUE (column);</p>
</li>
<li><p>普通索引 INDEX</p>
<p>  这是最基本的索引，它没有任何限制。可以在创建表的时候指定，也可以修改表结构，如：<br>  ALTER TABLE table_name ADD INDEX index_name (column);</p>
</li>
<li><p>组合索引 INDEX</p>
<p>  组合索引，即一个索引包含多个列。可以在创建表的时候指定，也可以修改表结构，如：<br>  ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);</p>
</li>
<li><p>全文索引 FULLTEXT</p>
<p>  全文索引（也称全文检索）是目前搜索引擎使用的一种关键技术。它能够利用分词技术等多种算法智能分析出文本文字中关键字词的频率及重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。<br>  可以在创建表的时候指定，也可以修改表结构，如：<br>  ALTER TABLE table_name ADD FULLTEXT (column);</p>
</li>
<li><p>查看索引 SHOW INDEX FROM table_name;</p>
</li>
<li>索引一旦创建后不能修改，如果需要修改，则需要删除重建，删除索引 DROP INDEX index_name ON table_name;</li>
</ul>
<h4 id="索引优点"><a href="#索引优点" class="headerlink" title="索引优点"></a>索引优点</h4><ul>
<li>索引大大减少了服务器需要扫描的数据量</li>
<li>索引可以帮助服务器避免排序和临时表</li>
<li>索引可以将随机IO变成顺序IO</li>
</ul>
<h4 id="建索引的策略"><a href="#建索引的策略" class="headerlink" title="建索引的策略"></a>建索引的策略</h4><ol>
<li><p>最左前缀匹配原则</p>
<p> mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整</p>
<p> 一般情况，在创建多列索引时，where子句中使用最频繁的一列放在最左边</p>
</li>
<li><p>=和in可以乱序</p>
<p> 比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</p>
</li>
<li><p>尽量选择区分度高的作为索引</p>
<p> 区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录</p>
</li>
<li><p>索引列不能参与计算，保持列“干净”</p>
</li>
<li><p>尽量的扩展索引，不要新建索引</p>
<p> 比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可</p>
</li>
</ol>
<h4 id="查询分析器-explain命令"><a href="#查询分析器-explain命令" class="headerlink" title="查询分析器-explain命令"></a>查询分析器-explain命令</h4><p> EXPLAIN SELECT * from trip_coord WHERE city=”cd”\G;<br> 对应的字段说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</div><div class="line">- select_type: SELECT 查询的类型.</div><div class="line">- table: 查询的是哪个表</div><div class="line">- type: join 类型</div><div class="line">- possible_keys: 此次查询中可能选用的索引</div><div class="line">- key: 此次查询中确切使用到的索引.</div><div class="line">- key_len: 索引长度</div><div class="line">- ref: 哪个字段或常数与 key 一起被使用</div><div class="line">- rows: 显示此查询一共扫描了多少行. 这个是一个估计值</div><div class="line">- filtered: 存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例(百分比)</div><div class="line">- extra: 额外的信息</div></pre></td></tr></table></figure></p>
<p>其中重要的字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">select_type:</div><div class="line">- SIMPLE, 表示此查询不包含 UNION 查询或子查询</div><div class="line">- PRIMARY, 表示此查询是最外层的查询</div><div class="line">- UNION, 表示此查询是 UNION 的第二或随后的查询</div><div class="line">- DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询</div><div class="line">- UNION RESULT, UNION 的结果</div><div class="line">- SUBQUERY, 子查询中的第一个 SELECT</div><div class="line">- DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</div><div class="line">- DERIVED：派生表的 SELECT(FROM 子句的子查询)</div><div class="line"> </div><div class="line">type:</div><div class="line">system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</div><div class="line">从左到右，性能由好到坏</div><div class="line">- ALL 全表扫描</div><div class="line">- index   索引全扫描</div><div class="line">- range   索引范围扫描</div><div class="line">- ref 非唯一索引扫描</div><div class="line">- eq_ref  唯一索引扫描</div><div class="line">- const,system    单表最多有一个匹配行</div><div class="line">- NULL    不用扫描表或索引</div><div class="line">ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.</div><div class="line"> </div><div class="line">key:MySQL 在当前查询时所真正使用到的索引.</div><div class="line"> </div><div class="line">key_len:</div><div class="line">表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到</div><div class="line">ref:</div><div class="line">显示索引的哪一列被使用了，如果可能的话，是一个常数</div><div class="line">rows:</div><div class="line">估算 SQL 要查找到结果集需要扫描读取的数据行数,原则上rows越小越好</div><div class="line">filtered:</div><div class="line">存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例(百分比)</div><div class="line">Extra:</div><div class="line">执行情况的说明和描述，包含不适合在其他列中显示但是对执行计划非常重要的额外信息</div><div class="line">主要包括：</div><div class="line">- Using Index   表示索引覆盖，不会回表查询</div><div class="line">- Using Where   表示进行了回表查询</div><div class="line">- Using Index Condition 表示进行了ICP优化</div><div class="line">- Using Flesort  表示MySQL需额外排序操作, 不能通过索引顺序达到排序效果</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;索引类型&quot;&gt;&lt;a href=&quot;#索引类型&quot; class=&quot;headerlink&quot; title=&quot;索引类型&quot;&gt;&lt;/a&gt;索引类型&lt;/h4&gt;&lt;p&gt;B-Tree索引：mysql引擎默认支持这种索引&lt;/p&gt;
&lt;p&gt;MyISAM 使用前缀技术使索引更小&lt;br&gt;InnoDB 按
    
    </summary>
    
      <category term="Mysql" scheme="https://ttxsgoto.github.io/categories/Mysql/"/>
    
    
      <category term="Index" scheme="https://ttxsgoto.github.io/tags/Index/"/>
    
  </entry>
  
  <entry>
    <title>(转)优化DRF的性能</title>
    <link href="https://ttxsgoto.github.io/2018/04/14/rest-framwork-serializer-efficient/"/>
    <id>https://ttxsgoto.github.io/2018/04/14/rest-framwork-serializer-efficient/</id>
    <published>2018-04-14T04:05:12.000Z</published>
    <updated>2018-04-14T04:14:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>看似简单直观的 Django REST Framework 及其<a href="http://www.django-rest-framework.org/api-guide/relations/#nested-relationships" target="_blank" rel="external">嵌套序列化</a>可能会大大降低你的 API 端的性能。你的服务器的其他部分的响应能力也会被某一个低效的 REST API 影响<br>问题的根源就是 「N+1 selects problem」；首先查询数据库一次得到表中的数据（例如，Customers），然后每个用户的其他字段又需要循环不止一次地查询数据库（例如 customer.country.Name）。使用 Django 的 ORM，很容易造成这个问题，而使用 DRF，同样会造成这个问题。</p>
<p>幸运的是，目前有修复 Django REST Framework 性能问题的解决方法，而且不需要对代码进行重大重组。它只是需要使用未充分利用的 select_related 和 prefetch_related 方法来执行所谓的「预加载」。</p>
<h4 id="为什么-Django-REST-Framework-那么容易造成这个问题"><a href="#为什么-Django-REST-Framework-那么容易造成这个问题" class="headerlink" title="为什么 Django REST Framework 那么容易造成这个问题"></a>为什么 Django REST Framework 那么容易造成这个问题</h4><p>当你建立一个 DRF 视图时，你经常需要从多个相关表中返回相应的数据。写这样的功能是很简单的，DRF文档中有详细的介绍。不过不幸的是，只要你在序列化中使用嵌套关系，你就在拿你的性能开玩笑，像很多的性能问题一样，它往往只出现有大型数据集的真实生产环境中。</p>
<p>这种情况发生就是因为 Django 的 ORM 是惰性的，它只取出当前查询所需响应最小的数据。它不知道你是否有成百上千的相同或相似的数据也需要取出来。</p>
<p>况且如今，当我们谈到数据库型网站时，一般情况下，最重要的响应指标就是数据库的访问次数。</p>
<p>在 DRF 视图中，我们每次序列化有嵌套关系的数据时都会出现问题，如下面的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span>  </div><div class="line">    <span class="comment"># This can kill performance!</span></div><div class="line">    order_descriptions = serializers.StringRelatedField(many=<span class="keyword">True</span>) </div><div class="line">    <span class="comment"># So can this, same exact problem...</span></div><div class="line">    orders = OrderSerializer(many=<span class="keyword">True</span>, read_only=<span class="keyword">True</span>) <span class="comment"># This can kill performance!</span></div></pre></td></tr></table></figure></p>
<p>CustomerSerializer 函数里面是这么运行的：</p>
<ul>
<li>获取所有的 customers (需要往返到数据库)</li>
<li>对于第一个返回的客户，获取他们的 orders (又需要去往返一趟数据库)</li>
<li>对于第二个返回的客户，获取他们的 orders (又需要去往返一趟数据库)</li>
<li>对于第三个返回的客户，获取他们的 orders (又需要去往返一趟数据库)</li>
<li>对于第四个返回的客户，获取他们的 orders (又需要去往返一趟数据库)</li>
<li>对于第五个返回的客户，获取他们的 orders (又需要去往返一趟数据库)</li>
<li>对于第六个返回的客户，获取他们的 orders (又需要去往返一趟数据库)</li>
<li>。。。。终于意识到，千万不要有更多的用户</li>
</ul>
<h4 id="解决-Django-「懒惰」的基本方法"><a href="#解决-Django-「懒惰」的基本方法" class="headerlink" title="解决 Django 「懒惰」的基本方法"></a>解决 Django 「懒惰」的基本方法</h4><p>现在我们解决这个问题的方法就是「预加载」。从本质上讲，就是你提前警告 Django ORM 你要一遍又一遍的告诉它同样无聊的指令。在上面的例子中，在 DRF 开始获取前很简单地加上这句话就搞定了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">queryset = queryset.prefetch_related(<span class="string">'orders'</span>)</div></pre></td></tr></table></figure></p>
<p>当 DRF 调用上述相同序列化 customers 时，出现的是这种情况：</p>
<ul>
<li>获取所有 customers（执行两个往返数据库操作，第一个是获取 customers，第二个获取相关 customers 的所有相关的 orders。）</li>
<li>对于第一个返回的 customers，获取其 order（不需要访问数据库，我们已经在上一步中获取了所需要的数据）</li>
<li>对于第二个返回的 customers，获取其 order （不需要访问数据库）</li>
<li>对于第三个返回的 customers，获取其 order （不需要访问数据库）</li>
<li>对于第四个返回的 customers，获取其 order （不需要访问数据库）</li>
<li>对于第五个返回的 customers，获取其 order （不需要访问数据库）</li>
<li>对于第六个返回的 customers，获取其 order （不需要访问数据库）</li>
<li>你又意识到，你可以有了很多 customers，已经不需要再继续等待去数据库。</li>
</ul>
<p>其实 Django ORM 的「预备」是在第1步进行请求，它在本地高速缓存的数据能够提供步骤2+所要求的数据。与之前往返数据库相比从本地缓存数据中读取数据基本上是瞬时的，所以我们在有很多 customers 时就获得了巨大的性能加速。</p>
<h4 id="解决-Django-REST-Framework-性能问题的标准化模式"><a href="#解决-Django-REST-Framework-性能问题的标准化模式" class="headerlink" title="解决 Django REST Framework 性能问题的标准化模式"></a>解决 Django REST Framework 性能问题的标准化模式</h4><p>我们已经确定了一个优化 Django REST Framework 性能问题的通用模式，那就是每当序列化查询嵌套字段时，我们就添加一个新的 @staticmethod 名叫 setup_eager_loading，像这样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span>  </div><div class="line">    orders = OrderSerializer(many=<span class="keyword">True</span>, read_only=<span class="keyword">True</span>)</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup_eager_loading</span><span class="params">(cls, queryset)</span>:</span></div><div class="line">        <span class="string">""" Perform necessary eager loading of data. """</span></div><div class="line">        queryset = queryset.prefetch_related(<span class="string">'orders'</span>)</div><div class="line">        <span class="keyword">return</span> queryset</div></pre></td></tr></table></figure></p>
<p>这样，不管哪里要用到这个序列化，都只需在调用序列化前简单调用 setup_eager_loading ，就像这样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">customer_qs = Customers.objects.all()  </div><div class="line">customer_qs = CustomerSerializer.setup_eager_loading(customer_qs)  <span class="comment"># Set up eager loading to avoid N+1 selects  </span></div><div class="line">post_data = CustomerSerializer(customer_qs, many=<span class="keyword">True</span>).data</div></pre></td></tr></table></figure></p>
<p>或者，如果你有一个 APIView 或 ViewSet，你可以在 get_queryset 方法里调用 setup_eager_loading：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span>  </div><div class="line">    queryset = Customers.objects.all()</div><div class="line">    <span class="comment"># Set up eager loading to avoid N+1 selects</span></div><div class="line">    queryset = self.get_serializer_class().setup_eager_loading(queryset)  </div><div class="line">    <span class="keyword">return</span> queryset</div></pre></td></tr></table></figure></p>
<h4 id="那么怎样编写-setup-eager-loading"><a href="#那么怎样编写-setup-eager-loading" class="headerlink" title="那么怎样编写 setup_eager_loading"></a>那么怎样编写 setup_eager_loading</h4><p>想要解决 Django 的性能问题，最困难的部分就是要熟悉 select_related ，我们将详细介绍它们在 Django ORM 和 Django REST Framework 中怎样使用。</p>
<ul>
<li>select_related：Django ORM 最简单的预加载工具，对于所有一对一或多对一的数据关系，你都需要从同一个父对象获取数据，如客户的公司名称。这个会被翻译成 SQL 的 join 操作，这样父对象的数据就和子对象的数据一起取回来了。（<a href="https://docs.djangoproject.com/en/dev/ref/models/querysets/#django.db.models.query.QuerySet.select_related" target="_blank" rel="external">参见官方文档</a>）</li>
<li>prefetch_related：对于更复杂的关系，即每个结果有多行（例如 many=True ），像多对一或多对多的数据关系，比如上述客户的订单，这转化一个二级 SQL 查询，通常有很长的 WHERE … IN ，从中只选择相关的行。（<a href="https://docs.djangoproject.com/en/dev/ref/models/querysets/#django.db.models.query.QuerySet.select_related" target="_blank" rel="external">参见官方文档</a>）</li>
<li>Prefetch：用于复杂 prefetch_related 查询，例如过滤子集。它也可以嵌套setup_eager_loading 进行调用。 （<a href="https://docs.djangoproject.com/en/dev/ref/models/querysets/#django.db.models.query.QuerySet.select_related" target="_blank" rel="external">参见官方文档</a>）</li>
</ul>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="http://blog.oneapm.com/apm-tech/304.html" target="_blank" rel="external">http://blog.oneapm.com/apm-tech/304.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看似简单直观的 Django REST Framework 及其&lt;a href=&quot;http://www.django-rest-framework.org/api-guide/relations/#nested-relationships&quot; target=&quot;_blank&quot; 
    
    </summary>
    
      <category term="DRF" scheme="https://ttxsgoto.github.io/categories/DRF/"/>
    
    
      <category term="ORM" scheme="https://ttxsgoto.github.io/tags/ORM/"/>
    
      <category term="Serializer" scheme="https://ttxsgoto.github.io/tags/Serializer/"/>
    
  </entry>
  
  <entry>
    <title>Django ORM数据查询操作优化</title>
    <link href="https://ttxsgoto.github.io/2018/04/13/django-orm-queryset/"/>
    <id>https://ttxsgoto.github.io/2018/04/13/django-orm-queryset/</id>
    <published>2018-04-13T14:47:47.000Z</published>
    <updated>2018-04-14T04:12:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近几天研究了一下django ORM查询优化，响应时间慢问题，主要原因还是代码规范和方法使用不当，如果正确使用相应方法，大部分的性能问题都是可以解决，记录如下：</p>
<h4 id="Django-QuerySet懒执行"><a href="#Django-QuerySet懒执行" class="headerlink" title="Django QuerySet懒执行"></a>Django QuerySet懒执行</h4><p>只有访问到对应的数据时，才会访问数据库，如果再次读取查询到的数据时，不会触发访问数据库操作，返回的是QuerySet、ValuesQuerySet、ValuesListQuerySet、Model实例<br>会执行数据库操作的操作有：</p>
<ul>
<li>Iteration，对Queryset进行迭代操作</li>
<li>slicing分片， 如queryset[:5]</li>
<li>序列化Pickling</li>
<li>repr()/str()将对象转为字符串</li>
<li>len()/list()/bool()/print()操作</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">######## 实例一 ########</span></div><div class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> connection</div><div class="line">users = User.objects.all()</div><div class="line">users = User.objects.all().select_related(<span class="string">'group'</span>)</div><div class="line"><span class="keyword">for</span> user <span class="keyword">in</span> users:</div><div class="line">    print(user.name) <span class="comment"># 这里只查询一次数据库</span></div><div class="line">    print(user.group.name) <span class="comment"># 这里的group为外键，查询次数依次增加, 可通过select_related()来解决多次查询数据库问题</span></div><div class="line">    l = connection.queries</div><div class="line">    print(len(l), l)</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="comment">######## 实例二 ########</span></div><div class="line"><span class="comment"># 这时不会访问数据库</span></div><div class="line">users = User.objects.filter(age=<span class="number">25</span>)</div><div class="line"> </div><div class="line"><span class="comment"># 这里需要访问数据，执行数据库查询操作</span></div><div class="line">list(users) <span class="keyword">or</span> <span class="keyword">if</span> users: <span class="keyword">pass</span></div><div class="line"> </div><div class="line"><span class="comment"># 再次读取数据，不会访问数据库</span></div><div class="line">user = users[<span class="number">0</span>]</div></pre></td></tr></table></figure>
<h4 id="使用select-related-提升关联外键-一对一关联查询"><a href="#使用select-related-提升关联外键-一对一关联查询" class="headerlink" title="使用select_related 提升关联外键/一对一关联查询"></a>使用select_related 提升关联外键/一对一关联查询</h4><p>Model中一般会定义外键关联，查询如果编写不当，会多次访问数据库查询，影响效率；通过select_related方法来查询外键(ForeignKey)或一对一(OneToOneField)关系，其实就是sql语句中join操作；在后面使用外键关系查询时将不需要执行数据库查询</p>
<p>使用prefetch_related提升关联多对多或多对一查询<br>prefetch_related 执行一个单独的查找，它允许预先读取多对多和多对一的对象数据，这是 select_related 做不到的。另外 perfetch_related 也可以与通用外键和关系一起使用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">######## 实例一 ########</span></div><div class="line">DeviceInfo.objects.filter(operator_id=<span class="string">'dc8b37483b27402d90a5a28d13ce330c'</span>)</div><div class="line"><span class="comment"># 对应sql如下：</span></div><div class="line">SELECT `device_info`.`id`, `device_info`.`number`, `device_info`.`type`, `device_info`.`plate_no_id`, `device_info`.`status`, `device_info`.`offline_date`,  `device_info`.`operator_id` FROM `device_info` WHERE `device_info`.`operator_id` = dc8b37483b27402d90a5a28d13ce330c</div><div class="line">DeviceInfo.objects.select_related(<span class="string">'operator'</span>).filter(operator_id=<span class="string">'dc8b37483b27402d90a5a28d13ce330c'</span>)</div><div class="line"><span class="comment"># 对应sql如下：</span></div><div class="line">SELECT `device_info`.`id`,  `device_info`.`number`, `device_info`.`type`, `device_info`.`plate_no_id`, `device_info`.`status`, `device_info`.`offline_date`, `device_info`.`operator_id`, `user`.`password`, `user`.`last_login`, `user`.`is_superuser`, `user`.`id`, `user`.`created_at`, `user`.`is_deleted`, `user`.`mobile_number`, `user`.`is_active`, `user`.`is_staff`, `user`.`is_driver`, `user`.`depgroup_id` FROM `device_info` INNER JOIN `user` ON (`device_info`.`operator_id` = `user`.`id`) WHERE `device_info`.`operator_id` = dc8b37483b27402d90a5a28d13ce330c</div><div class="line"> </div><div class="line"><span class="comment">######## 实例二 ########</span></div><div class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">City</span><span class="params">(models.Model)</span>:</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(models.Model)</span>:</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line">    hometown = models.ForeignKey(City)</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span><span class="params">(models.Model)</span>:</span></div><div class="line">    <span class="comment"># ...</span></div><div class="line">    author = models.ForeignKey(Person)</div><div class="line"> </div><div class="line">b = Book.objects.select_related(<span class="string">'author__hometown'</span>).get(id=<span class="number">4</span>)</div><div class="line">p = b.author         <span class="comment"># Doesn't hit the database.</span></div><div class="line">c = p.hometown       <span class="comment"># Doesn't hit the database.</span></div><div class="line"> </div><div class="line">b = Book.objects.get(id=<span class="number">4</span>) <span class="comment"># No select_related() in this example.</span></div><div class="line">p = b.author         <span class="comment"># Hits the database.</span></div><div class="line">c = p.hometown       <span class="comment"># Hits the database.</span></div></pre></td></tr></table></figure></p>
<h4 id="不要查询不需要的值"><a href="#不要查询不需要的值" class="headerlink" title="不要查询不需要的值"></a>不要查询不需要的值</h4><ul>
<li>通过values和values_list来限制返回值</li>
<li>通过only指定字段和defer排除字段</li>
<li>如果只需要id，可以使用queryset.values_list(‘id’, flat=True)</li>
</ul>
<h4 id="直接使用外键值"><a href="#直接使用外键值" class="headerlink" title="直接使用外键值"></a>直接使用外键值</h4><p>如果只想获取外键id，可通过obj_id的方式获取，优先于obj.id;obj.id方式会为子表内容保存额外查询</p>
<h4 id="用count-代替len-exists-代替if-queryset"><a href="#用count-代替len-exists-代替if-queryset" class="headerlink" title="用count()代替len(), exists()代替if queryset"></a>用count()代替len(), exists()代替if queryset</h4><p>len()方法相当于会把整个queryset遍历一次，把所有的数据都取出来对象化，消耗大量的资源</p>
<h4 id="对缓存的queryset只进行一次遍历，使用iterator"><a href="#对缓存的queryset只进行一次遍历，使用iterator" class="headerlink" title="对缓存的queryset只进行一次遍历，使用iterator()"></a>对缓存的queryset只进行一次遍历，使用iterator()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 如此操作可减少数据载入内存中，同时和values一起使用可大大减少内存的使用</span></div><div class="line"><span class="keyword">for</span> user <span class="keyword">in</span> User.objects.all().iterator():</div><div class="line">    do_something(user)</div></pre></td></tr></table></figure>
<h4 id="避免多次查询"><a href="#避免多次查询" class="headerlink" title="避免多次查询"></a>避免多次查询</h4><p>筛选表中不同条件的数据时，一般采用写多个查询进行筛选，数据多时严重影响性能<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">users = [</div><div class="line"><span class="string">'ttxsgoto01'</span>,</div><div class="line"><span class="string">'ttxsgoto02'</span>,</div><div class="line"><span class="string">'ttxsgoto03'</span>,</div><div class="line">]</div><div class="line"><span class="keyword">from</span> models <span class="keyword">import</span> User</div><div class="line"><span class="comment">######## 实例一 ########</span></div><div class="line"><span class="comment"># 这里会进行多次数据库查询操作</span></div><div class="line"><span class="keyword">for</span> user <span class="keyword">in</span> users:</div><div class="line">    user1 = User.objects.filter(username=user, age=<span class="number">21</span>)</div><div class="line">    user2 = User.objects.filter(username=user, age=<span class="number">22</span>)</div><div class="line">    user3 = User.objects.filter(username=user, age=<span class="number">23</span>)</div><div class="line">    user4 = User.objects.filter(username=user, sex=<span class="string">'M'</span>)</div><div class="line">    print(user1.count(), user2.count(), user3.count(), user4.count())</div><div class="line"> </div><div class="line"><span class="comment">######## 实例二 ########</span></div><div class="line"><span class="comment"># 减少数据库查询，一次把数据查询出来</span></div><div class="line"><span class="keyword">for</span> user <span class="keyword">in</span> users:</div><div class="line">    _user = User.objects.filter(username=user).values_list(<span class="string">'age'</span>, <span class="string">'sex'</span>)</div><div class="line">    user1 = filter(<span class="keyword">lambda</span> x:<span class="keyword">True</span> <span class="keyword">if</span> x[<span class="number">0</span>]==<span class="number">21</span> <span class="keyword">else</span> <span class="keyword">False</span>, _user)</div><div class="line">    user2 = filter(<span class="keyword">lambda</span> x:<span class="keyword">True</span> <span class="keyword">if</span> x[<span class="number">0</span>]==<span class="number">22</span> <span class="keyword">else</span> <span class="keyword">False</span>, _user)</div><div class="line">    user3 = filter(<span class="keyword">lambda</span> x:<span class="keyword">True</span> <span class="keyword">if</span> x[<span class="number">0</span>]==<span class="number">23</span> <span class="keyword">else</span> <span class="keyword">False</span>, _user)</div><div class="line">    user4 = filter(<span class="keyword">lambda</span> x:<span class="keyword">True</span> <span class="keyword">if</span> x[<span class="number">1</span>]==<span class="string">'M'</span> <span class="keyword">else</span> <span class="keyword">False</span>, _user)</div><div class="line">    print(user1.count(), user2.count(), user3.count(), user4.count())</div><div class="line"><span class="comment"># 如此操作，一个条件只执行一次数据库查询，不同于实例一中会执行多次数据库查询</span></div></pre></td></tr></table></figure></p>
<h4 id="创建表索引"><a href="#创建表索引" class="headerlink" title="创建表索引"></a>创建表索引</h4><p>根据业务需求，创建对应的索引字段</p>
<h4 id="对于复杂的数据库查询操作，使用原生SQL实现"><a href="#对于复杂的数据库查询操作，使用原生SQL实现" class="headerlink" title="对于复杂的数据库查询操作，使用原生SQL实现"></a>对于复杂的数据库查询操作，使用原生SQL实现</h4><h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><h5 id="方法一-code"><a href="#方法一-code" class="headerlink" title="方法一: code"></a>方法一: code</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> connection</div><div class="line">dbsql = connection.queries <span class="comment"># 具体sql执行情况和耗时情况</span></div></pre></td></tr></table></figure>
<h5 id="方法二-shell"><a href="#方法二-shell" class="headerlink" title="方法二: shell"></a>方法二: shell</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- pip install django-extensions</div><div class="line">- INSTALLED_APPS = (</div><div class="line">    ...</div><div class="line">    <span class="string">'django_extensions'</span>,</div><div class="line">    ...</div><div class="line"> )</div><div class="line">- python manage.py shell_plus --<span class="keyword">print</span>-sql <span class="comment"># 查看执行sql和结果</span></div></pre></td></tr></table></figure>
<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><ul>
<li><a href="https://docs.djangoproject.com/en/1.10/topics/db/optimization/" target="_blank" rel="external">https://docs.djangoproject.com/en/1.10/topics/db/optimization/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近几天研究了一下django ORM查询优化，响应时间慢问题，主要原因还是代码规范和方法使用不当，如果正确使用相应方法，大部分的性能问题都是可以解决，记录如下：&lt;/p&gt;
&lt;h4 id=&quot;Django-QuerySet懒执行&quot;&gt;&lt;a href=&quot;#Django-QueryS
    
    </summary>
    
      <category term="Django" scheme="https://ttxsgoto.github.io/categories/Django/"/>
    
    
      <category term="ORM" scheme="https://ttxsgoto.github.io/tags/ORM/"/>
    
      <category term="Queryset" scheme="https://ttxsgoto.github.io/tags/Queryset/"/>
    
  </entry>
  
</feed>
