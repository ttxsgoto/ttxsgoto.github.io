<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ttxsgoto&#39; Blog</title>
  <subtitle>好好学习 努力工作 享受生活</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ttxsgoto.github.io/"/>
  <updated>2017-02-08T14:50:30.000Z</updated>
  <id>https://ttxsgoto.github.io/</id>
  
  <author>
    <name>ttxsgoto</name>
    <email>zhongqiang2014@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>docker—网络模式</title>
    <link href="https://ttxsgoto.github.io/2017/02/08/docker_network/"/>
    <id>https://ttxsgoto.github.io/2017/02/08/docker_network/</id>
    <published>2017-02-08T14:05:33.000Z</published>
    <updated>2017-02-08T14:50:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Docker网络实现原理"><a href="#Docker网络实现原理" class="headerlink" title="Docker网络实现原理"></a>Docker网络实现原理</h3><p>Docker 中的网络接口默认都是虚拟的接口。虚拟接口的优势之一是转发效率较高。 Linux 通过在内核中进 行数据复制来实现虚拟接口之间的数据转发，发送接口的发送缓存中的数据包被直接复制到接收接口的接收缓存中。对于本地系统和容器内系统看来就像是一个正常的以太网卡，只是它不需要真正同外部网络设备通信，速度要快很多；Docker 容器网络利用此技术，它在本地主机和容器内分别创建一个虚拟接口，并让它们彼此连通 （这样的一对接口叫做 veth pair ）</p>
<p>Docker 创建一个容器的时候，会执行如下操作：</p>
<ul>
<li>创建一对虚拟接口，分别放到本地主机和新容器中； </li>
<li>本地主机一端桥接到默认的 docker0 或指定网桥上，并具有一个唯一的名字，如 vethf9； </li>
<li>容器一端放到新容器中，并修改名字作为 eth0，这个接口只在容器的名字空间可见； </li>
<li>从网桥可用地址段中获取一个空闲地址分配给容器的 eth0，并配置默认路由到桥接网卡 vethf9。 </li>
</ul>
<p>完成这些之后，容器就可以使用 eth0 虚拟网卡来连接其他容器和其他网络</p>
<p>网络模式需要开启linux系统转发功能，查看linux系统中是否开启转发功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#sysctl net.ipv4.ip_forward</div><div class="line">net.ipv4.ip_forward = 1</div><div class="line"># 设置：sysctl -w  net.ipv4.ip_forward=1</div></pre></td></tr></table></figure></p>
<h3 id="几种网络模式"><a href="#几种网络模式" class="headerlink" title="几种网络模式"></a>几种网络模式</h3><h4 id="nat"><a href="#nat" class="headerlink" title="nat"></a>nat</h4><p>–net=bridge (默认的网桥)，Docker通过宿主机的网桥(docker0)来连通内部和宿主机的网络，实现了容器与宿主机和外界之间的网络通信<br><img src="https://ttxsgoto.github.io/img/docker_network/1.png" alt="nat模型"></p>
<p>Bridge桥接模式的实现步骤主要如下：</p>
<p>（1）Docker Daemon利用veth pair技术，在宿主机上创建两个虚拟网络接口设备，假设为veth0和veth1。而veth pair技术的特性可以保证无论哪一个veth接收到网络报文，都会将报文传输给另一方。</p>
<p>（2）Docker Daemon将veth0附加到Docker Daemon创建的docker0网桥上。保证宿主机的网络报文可以发往veth0。</p>
<p>（3）Docker Daemon将veth1添加到Docker Container所属的namespace下，并被改名为eth0。如此一来，保证宿主机的网络报文若发往veth0，则立即会被eth0接收，实现宿主机到Docker Container网络的联通性；同时，也保证Docker Container单独使用eth0，实现容器网络环境的隔离性。</p>
<p>同时Docker采用NAT（Network Address Translation，网络地址转换）的方式(可自行查询实现原理)，让宿主机以外的世界可以主动将网络报文发送至容器内部。</p>
<p>通过Bridger网桥模式实现：</p>
<p>（1）容器拥有独立、隔离的网络栈</p>
<p>（2）容器和宿主机以外的世界通过NAT建立通信</p>
<h4 id="host"><a href="#host" class="headerlink" title="host"></a>host</h4><p>–net=host (告诉docker不要将容器网络放在隔离的名字容器中，即不要容器化容器内的网络，该模式下的Docker Container和host宿主机共享同一个网络namespace，即container和宿主机一样，使用宿主机的eth0)<br><img src="https://ttxsgoto.github.io/img/docker_network/2.png" alt="host模型"></p>
<p>Docker Container的host网络模式在实现过程中，由于不需要额外的网桥以及虚拟网卡，故不会涉及docker0以及veth pair。父进程在创建子进程时，如果不使用CLONE_NEWNET这个参数标志，那么创建出的子进程会与父 进程共享同一个网络namespace。Docker就是采用了这个简单的原理，在创建进程启动容器的过程中，没有传入CLONE_NEWNET参数标 志，实现Docker Container与宿主机共享同一个网络环境，即实现host网络模式。</p>
<p>Docker Container的网络模式中，host模式是bridge桥接模式很好的补充。采用host模式的Docker Container，可以直接使用宿主机的IP地址与外界进行通信，若宿主机的eth0是一个公有IP，那么容器也拥有这个公有IP。同时容器内服务的端口也可以使用宿主机的端口，无需额外进行NAT转换。当然，有这样的方便，肯定会损失部分其他的特性，最明显的是Docker Container网络环境隔离性的弱化，即容器不再拥有隔离、独立的网络栈。另外，使用host模式的Docker Container虽然可以让容器内部的服务和传统情况无差别、无改造的使用，但是由于网络隔离性的弱化，该容器会与宿主机共享竞争网络栈的使用；另外，容器内部将不再拥有所有的端口资源，原因是部分端口资源已经被宿主机本身的服务占用，还有部分端口已经用以bridge网络模式容器的端口映射。</p>
<h4 id="Other-container"><a href="#Other-container" class="headerlink" title="Other container"></a>Other container</h4><p>–net=container:NAME_or_ID  (让docker将新建容器的进程放到一个已存在容器的网络栈中，新容器进程有自己的文件系统、进程列表和资源限制，但会和已存在的容器共享IP地址和端口等网络资源，两者进程可以直接通过lo 环回接口通信)<br><img src="https://ttxsgoto.github.io/img/docker_network/3.png" alt="other模型"></p>
<p>上图右侧的Docker Container即采用了other container网络模式，它能使用的网络环境即为左侧Docker Container brdige桥接模式下的网络</p>
<p>Docker Container的other container网络模式在实现过程中，不涉及网桥，同样也不需要创建虚拟网卡veth pair。</p>
<p>完成other container网络模式的创建只需要两个步骤：</p>
<p>(1) 查找other container（即需要被共享网络环境的容器）的网络namespace；</p>
<p>(2) 将新创建的Docker Container（也是需要共享其他网络的容器）的namespace，使用other container的namespace<br>在这种模式下的Docker Container可以通过localhost来访问namespace下的其他容器，传输效率较高。虽然多个容器共享网络环境，但是多个容器形成的整体依然与宿主机以及其他容器形成网络隔离。另外，这种模式还节约了一定数量的网络资源。但是需要注意的是，它并没有改善容器与宿主机以外世界通信的情况。</p>
<h4 id="none"><a href="#none" class="headerlink" title="none"></a>none</h4><p>–net=none   (让Docker将新容器放到隔离的网络栈中，但不进行网络配置，之后用户可以自己进行配置，容器内部只能使用loopback网络设备，不会再有其他的网络资源)</p>
<h3 id="网络相关的命令"><a href="#网络相关的命令" class="headerlink" title="网络相关的命令"></a>网络相关的命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-b BRIDGE or --bridge=BRIDGE --指定容器挂载的网桥</div><div class="line">--bip=CIDR --定制 docker0 的掩码</div><div class="line">-H SOCKET... or --host=SOCKET... --Docker 服务端接收命令的通道</div><div class="line">--icc=true|false --是否支持容器之间进行通信</div><div class="line">--ip-forward=true|false --容器之间的通信</div><div class="line">--iptables=true|false --禁止 Docker 添加 iptables 规则</div><div class="line">--mtu=BYTES --容器网络中的 MTU</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Docker网络实现原理&quot;&gt;&lt;a href=&quot;#Docker网络实现原理&quot; class=&quot;headerlink&quot; title=&quot;Docker网络实现原理&quot;&gt;&lt;/a&gt;Docker网络实现原理&lt;/h3&gt;&lt;p&gt;Docker 中的网络接口默认都是虚拟的接口。虚拟接口的优势
    
    </summary>
    
      <category term="Docker" scheme="https://ttxsgoto.github.io/categories/Docker/"/>
    
    
      <category term="Network" scheme="https://ttxsgoto.github.io/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>awk、uniq、sort三个命令的基本用法</title>
    <link href="https://ttxsgoto.github.io/2017/02/07/awk_uniq_sort/"/>
    <id>https://ttxsgoto.github.io/2017/02/07/awk_uniq_sort/</id>
    <published>2017-02-07T14:38:32.000Z</published>
    <updated>2017-02-07T14:32:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天对awk、uniq、sort三个命令做了基础功能的学习，这里自己记录一下：</p>
<h4 id="1-awk"><a href="#1-awk" class="headerlink" title="1.awk"></a>1.awk</h4><p>数据处理工具，将一行分割成多个“字段”来处理</p>
<pre><code>awk -F &apos;文本切割符&apos;‘{处理过程}’ 文件名称
</code></pre><p>如：cat /ect/passwd | awk -F ‘:’ ‘{print $1}’   #以：分割，打印第一列的数据；如果为$0表示整个文件内容</p>
<pre><code>cat /etc/passwd | awk -F &apos;&apos;BEGIN {print &quot;begin,goto&quot;} {print $1&quot;,&quot;$7} END {print “end,end”}  #以空白符作为分割，打印begin，goto开始执行信息，打印1，7行，以end,end结束
</code></pre><h4 id="2-uniq"><a href="#2-uniq" class="headerlink" title="2.uniq"></a>2.uniq</h4><p>命令用来过滤重复部分显示文件内容,这个命令读取输入文件，并比较相邻的行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">参数：</div><div class="line"></div><div class="line">-c  显示输出中，在每行行首加上本行在文件中出现的次数</div><div class="line">-d  只显示重复行</div><div class="line">-u  只显示文件中不重复的各行</div><div class="line">-n  前n个字段与每个字段前的空白一起被忽略</div><div class="line">+n  前n个字符被忽略，之前的字符被跳过（字符从0开始编号）</div><div class="line">-f   n与-n相同，这里n是字段数</div><div class="line">-s   n与+n相同，这里n是字符数</div><div class="line">常用： uniq -c  首行显示文件中出现的次数</div></pre></td></tr></table></figure></p>
<h4 id="3-sort-排序"><a href="#3-sort-排序" class="headerlink" title="3.sort 排序"></a>3.sort 排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">参数：</div><div class="line">-u  在输出行中去除重复行</div><div class="line">-r   默认的排序方式为升序，-r转换为降序排列</div><div class="line">-n  默认按照字符来排序出现10在2前面，-n以数值来排序</div><div class="line">-t   后面设定间隔符</div><div class="line">-k  指定列数</div><div class="line">如：sort -n -k 2 -t ： test.txt  以数值排序，按照第二列以“：”间隔来排列顺序</div></pre></td></tr></table></figure>
<p>以上简单总结而已，后续如有其他使用，再更新！！！</p>
<h4 id="4-日常使用相关"><a href="#4-日常使用相关" class="headerlink" title="4.日常使用相关"></a>4.日常使用相关</h4><ul>
<li><p>截取日志中特定时间段的日志内容</p>
<pre><code>sed -n &apos;/2016-08-25 09:44:10/,/2016-08-25 09:44:30/p&apos;  1.txt &gt; test.txt
</code></pre></li>
</ul>
<ul>
<li><p>nginx 访问日志统计访问的url</p>
<p>  截取特定时间段的日志</p>
<pre><code>cat nginx.acc.log | egrep &quot;12/Aug/2016&quot; | sed -n &apos;/14:59:44/,/15:47:23/p&apos; &gt; a.txt
</code></pre></li>
<li><p>排序</p>
<pre><code>cat a.txt |awk -F &apos;+0800&apos; &apos;{print $2}&apos;| awk -F &apos; &apos; &apos;{print $5}&apos; | sort #对数据进行(ASCII)排序  
</code></pre></li>
<li><p>去重，uniq -c 只会合并相邻的记录，所以在使用它之前，应该先进行排序</p>
<pre><code>cat a.txt |awk -F &apos;+0800&apos; &apos;{print $2}&apos;| awk -F &apos; &apos; &apos;{print $5}&apos; | sort | uniq -c
</code></pre></li>
<li><p>再排序，得到 (次数  内容)的文件， sort -k 1 -n -r 指定对第一行进行排序，-n 数字排序，以降序排列</p>
<pre><code>cat a.txt |awk -F &apos;+0800&apos; &apos;{print $2}&apos;| awk -F &apos; &apos; &apos;{print $5}&apos; | sort | uniq -c | sort -k 1 -n -r
</code></pre></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天对awk、uniq、sort三个命令做了基础功能的学习，这里自己记录一下：&lt;/p&gt;
&lt;h4 id=&quot;1-awk&quot;&gt;&lt;a href=&quot;#1-awk&quot; class=&quot;headerlink&quot; title=&quot;1.awk&quot;&gt;&lt;/a&gt;1.awk&lt;/h4&gt;&lt;p&gt;数据处理工具，将一行分
    
    </summary>
    
      <category term="运维" scheme="https://ttxsgoto.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="awk" scheme="https://ttxsgoto.github.io/tags/awk/"/>
    
      <category term="sort" scheme="https://ttxsgoto.github.io/tags/sort/"/>
    
      <category term="uniq" scheme="https://ttxsgoto.github.io/tags/uniq/"/>
    
  </entry>
  
  <entry>
    <title>pycharm,vim,items2常用快捷键</title>
    <link href="https://ttxsgoto.github.io/2017/02/06/vim/"/>
    <id>https://ttxsgoto.github.io/2017/02/06/vim/</id>
    <published>2017-02-06T14:05:33.000Z</published>
    <updated>2017-02-07T13:37:49.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="熟练掌握下面快捷键的使用-方便查询"><a href="#熟练掌握下面快捷键的使用-方便查询" class="headerlink" title="熟练掌握下面快捷键的使用(方便查询)"></a>熟练掌握下面快捷键的使用(方便查询)</h4><hr>
<h5 id="Pycharm日常快捷键"><a href="#Pycharm日常快捷键" class="headerlink" title="Pycharm日常快捷键"></a>Pycharm日常快捷键</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">- cmd + b           跳转到声明处(cmd + 鼠标)</div><div class="line">- cmd + y           显示方法对应的代码</div><div class="line">- cmd + []          光标之前/后的位置</div><div class="line">- cmd + del         删除当前行</div><div class="line">- cmd + o           搜索class</div><div class="line">- cmd + l           指定行数跳转</div><div class="line">- cmd + shift + o   搜索文件</div><div class="line">- cmd + opt + o     搜索函数</div><div class="line">- cmd + +           展开当前</div><div class="line">- cmd + -           收缩当前</div><div class="line">- cmd + shift + +   展开所有</div><div class="line">- cmd + shift + -   收缩所有</div><div class="line">- cmd + fn + F2     停止运行程序</div><div class="line">- cmd + /           注释/取消注释</div><div class="line">- cmd + fn + F12    显示文件结构</div><div class="line">- cmd + d           在下一行复制本行的内容</div><div class="line">- cmd + up/down     转到其他目录中</div><div class="line">- alt + enter       自动添加包</div><div class="line">- alt + del         向前删除一个字符串</div><div class="line">- alt + up          选中一个单词</div><div class="line">- alt + control + i 自动缩进行</div><div class="line">- double shift      选择需要查看的文件</div><div class="line">- alt + r           启动程序</div><div class="line">- alt + d           debug启动程序</div></pre></td></tr></table></figure>
<hr>
<h5 id="Vim日常快捷键"><a href="#Vim日常快捷键" class="headerlink" title="Vim日常快捷键"></a>Vim日常快捷键</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- hjkl              左下上右</div><div class="line">- gg                跳到文首</div><div class="line">- G                 跳到文末</div><div class="line">- M                 跳到当前页屏幕中间</div><div class="line">- &apos;0                光标跳到上次关闭文件前的位置</div><div class="line">- control + b       向上翻页</div><div class="line">- control + f       向下翻页</div><div class="line">- dw                删除一个单词</div><div class="line">- D                 删除所在行光标后面的内容</div><div class="line">- d0                删除所在行光标前面的内容</div><div class="line">- x/X               向后删除一个字符，X为向前删除一个字符</div><div class="line">- 0                 移动到当前行的第一个字符处</div><div class="line">- $                 移动到当前行的最后一个字符处</div><div class="line">- u                 撤销之前的操作</div><div class="line">- control + r       向后执行刚才撤销的内容</div><div class="line">- n                 查询时向下重复前一个查询操作</div><div class="line">- N                 查询时向上重复前一个查询操作</div><div class="line">- :s/old/new/g      用new替换行中所有的old</div><div class="line">- %s/old/new/g      用new替换当前文件里所有的old</div><div class="line">- v                 字符选择</div><div class="line">- V                 行选择</div><div class="line">- ctrl+v            块选择</div><div class="line"></div><div class="line">可用于在选中的行上插入相同的内容</div><div class="line">- 定位光标</div><div class="line">- crtl+v           进入块编辑模式</div><div class="line">- I                大写字母I，然后插入字符</div><div class="line">- ESC              按两下esc 即可添加相同内容到对应的行</div></pre></td></tr></table></figure>
<hr>
<h5 id="Items2常用快捷键"><a href="#Items2常用快捷键" class="headerlink" title="Items2常用快捷键"></a>Items2常用快捷键</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- cmd + t           新建标签</div><div class="line">- cmd + w           关闭标签</div><div class="line">- cmd + L/R         左右切换标签</div><div class="line">- cmd + ;           查看历史命令</div><div class="line">- cmd + r           清屏</div><div class="line">- cmd + d           垂直分屏</div><div class="line">- cmd + shift + d   水平分屏</div><div class="line">- control + a       到行首</div><div class="line">- control + e       到行末</div><div class="line">- control + d       删除当前光标的字符</div><div class="line">- 选中即复制 + 鼠标中键粘贴</div></pre></td></tr></table></figure>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;熟练掌握下面快捷键的使用-方便查询&quot;&gt;&lt;a href=&quot;#熟练掌握下面快捷键的使用-方便查询&quot; class=&quot;headerlink&quot; title=&quot;熟练掌握下面快捷键的使用(方便查询)&quot;&gt;&lt;/a&gt;熟练掌握下面快捷键的使用(方便查询)&lt;/h4&gt;&lt;hr&gt;
&lt;h5 id
    
    </summary>
    
      <category term="运维" scheme="https://ttxsgoto.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="vim" scheme="https://ttxsgoto.github.io/tags/vim/"/>
    
      <category term="pycharm" scheme="https://ttxsgoto.github.io/tags/pycharm/"/>
    
      <category term="items2" scheme="https://ttxsgoto.github.io/tags/items2/"/>
    
  </entry>
  
  <entry>
    <title>CPU性能命令</title>
    <link href="https://ttxsgoto.github.io/2017/02/05/cpu/"/>
    <id>https://ttxsgoto.github.io/2017/02/05/cpu/</id>
    <published>2017-02-05T14:05:33.000Z</published>
    <updated>2017-02-07T14:30:58.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><hr>
<p>CPU使用率:通过测量一段时间内cpu实例忙于执行工作的时间比例获得，以百分比表示</p>
<p>CPI(每指令周期数)：用来描述cpu如何使用它的时钟周期，同时也可以用来理解CPU使用率的本质；CPI较高代表cpu进场陷入停滞，通常都是在访问内存，较低的CPI表示cpu基本没有停滞，指令吞吐较高</p>
<p>IPC(每周期指令数)：它为CPI的倒数</p>
<p>饱和度：一个100%使用率的cpu称为饱和</p>
<h4 id="CPU使用说明例子"><a href="#CPU使用说明例子" class="headerlink" title="CPU使用说明例子"></a>CPU使用说明例子</h4><blockquote>
<p>CPU 很无辜，是个任劳任怨的打工仔，每时每刻都有工作在做（进程、线程）并且自己有一张工作清单（可运行队列），由老板（进程调度）来决定他该干什么，他需要 和老板沟通以便得到老板的想法并及时调整自己的工作（上下文切换），部分工作做完以后还需要及时向老板汇报（中断），所以打工仔（CPU）除了做自己该做 的工作以外，还有大量时间和精力花在沟通和汇报上。</p>
<p>打工仔接受和完成多少任务并向老板汇报了（中断）；</p>
<p>打工仔和老板沟通、协商每项工作的工作进度（上下文切换）；</p>
<p>打工仔的工作列表是不是都有排满（可运行队列）；</p>
<p>打工仔工作效率如何，是不是在偷懒（CPU 利用率）。</p>
</blockquote>
<h4 id="性能命令如下"><a href="#性能命令如下" class="headerlink" title="性能命令如下"></a>性能命令如下</h4><pre><code>- uptime
- top
- vmstart
- mpstat
- pidstat
- dstat
</code></pre><p>说明如下：</p>
<h5 id="uptime命令，用来统计系统当前的运行状态"><a href="#uptime命令，用来统计系统当前的运行状态" class="headerlink" title="uptime命令，用来统计系统当前的运行状态"></a>uptime命令，用来统计系统当前的运行状态</h5><pre><code>12:02:32 up 235 days, 18:58,  4 users,  load average: 0.02, 0.10, 0.07
</code></pre><p>其中load average这三个值表示系统在1min，5min，15min内的平均负载，这三个值一般不能大于系统CPU的个数。如果长期大于cpu个数表示cpu不足以服务线程，说明cpu繁忙，有些线程在等待，可能会影响系统性能</p>
<p>平均负载：表示对cpu资源的需求，通过汇总正在运行的线程数（使用率）和正在排队等待运行的线程数(饱和度)计算得到.</p>
<h5 id="top-查看负载情况-主要关注负载1-5-15min"><a href="#top-查看负载情况-主要关注负载1-5-15min" class="headerlink" title="top    查看负载情况 主要关注负载1,5,15min"></a>top    查看负载情况 主要关注负载1,5,15min</h5><p>该命令显示了最消耗cpu的任务，并带有cpu消耗百分比，TIME和%CPU显示了CPU占用的时间（这里是分钟时间）</p>
<pre><code>ps aux|head -1;ps aux|grep -v PID|sort -rn -k +3|head  查看占用cpu资源最多的10个进程方法

ps aux|head -1;ps aux|grep -v PID|sort -rn -k +4|head  查看占用内存资源最多的10个进程方法

ps -eo comm,pid,pcpu,pmem --sort -pcpu | head -20
</code></pre><h5 id="vmstart-命令（虚拟内存统计），"><a href="#vmstart-命令（虚拟内存统计），" class="headerlink" title="vmstart 命令（虚拟内存统计），"></a>vmstart 命令（虚拟内存统计），</h5><p>最后几列显示了cpu平均负载，少于10%可能是一个有问题<br>vmstart [-V] [-n] [delay [count]]</p>
<pre><code>-V  表示打印出版本信息，可选参数  
-n  表示在周期性循环输出，输出的头部信息仅显示一次
delay 表示两次输出之间的时间间隔
count 表示按照“delay”指定的时间间隔统计的次数，默认为1次
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">vmstart 3 5</div><div class="line">1 procs -----------memory----------  ---swap-- -----io---- --system-- -----cpu-----</div><div class="line">2 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</div><div class="line">3 2  0   7400 171448 171212 7667080    0    0    70   605    0    0  2  1 97  1  0</div><div class="line">4 0  0   7400 171828 171212 7667100    0    0     0  2387 1322 1572  1  1 99  0  0</div></pre></td></tr></table></figure>
<p>在cpu评估中，主要注意procs项中的r项的值和cpu项中us、sy和id列的值<br>这些值都是所有cpu的系统平均数，r除外，是总数r 应小于cpu个数<br>当脏页达到内存页面设置的值时，开始写入硬盘，通过  /sbin/sysctl -n vm.dirty_background_ratio   查看，默认值为10<br>当系统物理内存剩余量在该值范围时，开始大量使用swap交换空间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">r，所有等待的加上正在运行的线程数，这些线程都是可运行状态，只不过 CPU 暂时不可用；</div><div class="line">b，被 blocked 的进程数，正在等待 IO 请求；</div><div class="line">in，被处理过的中断数</div><div class="line">cs，系统上正在做上下文切换的数目</div><div class="line">us，用户占用 CPU 的百分比</div><div class="line">sys，内核和中断占用 CPU 的百分比</div><div class="line">wa，所有可运行的线程被 blocked 以后都在等待 IO，这时候 CPU 空闲的百分比</div><div class="line">id，CPU 完全空闲的百分比</div><div class="line">swpd，已使用的 SWAP 空间大小，KB 为单位；</div><div class="line">free，可用的物理内存大小，KB 为单位；</div><div class="line">buff，物理内存用来缓存读写操作的 buffer 大小，KB 为单位；</div><div class="line">cache，物理内存用来缓存进程地址空间的 cache 大小，KB 为单位；</div><div class="line">si，数据从 SWAP 读取到 RAM（swap in）的大小，KB 为单位；</div><div class="line">so，数据从 RAM 写到 SWAP（swap out）的大小，KB 为单位；</div><div class="line">bi，磁盘块从文件系统或 SWAP 读取到 RAM（blocks in）的大小，block 为单位；</div><div class="line">bo，磁盘块从 RAM 写到文件系统或 SWAP（blocks out）的大小，block 为单位；</div></pre></td></tr></table></figure></p>
<h5 id="mpstat命令"><a href="#mpstat命令" class="headerlink" title="mpstat命令"></a>mpstat命令</h5><p>(每个CPU统计信息）,检查单个cpu是否繁忙<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">mpstat -P ALL 1</div><div class="line">05:43:50 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest   %idle</div><div class="line">05:43:51 PM  all    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</div><div class="line">05:43:51 PM    0    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</div><div class="line">05:43:51 PM    1    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</div><div class="line">05:43:51 PM    2    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</div><div class="line">05:43:51 PM    3    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</div><div class="line">05:43:51 PM    4    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</div><div class="line">05:43:51 PM    5    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</div><div class="line">05:43:51 PM    6    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</div><div class="line">05:43:51 PM    7    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</div><div class="line"></div><div class="line">-P ALL 用来打印每个CPU的信息</div><div class="line">-P 1 1  用来打印第二个cpu的信息</div><div class="line">%usr ：用户态时间</div><div class="line">%nice :以nice优先级运行的进程用户态时间</div><div class="line">%sys ：系统态时间（内核）</div><div class="line">%iowait ：I/O等待</div><div class="line">%irq   ：硬件中断CPU用量</div><div class="line">%soft  ：软件中断CPU用量</div><div class="line">%steal ：耗费在服务其他租户的时间</div><div class="line">%guest ：花在访客虚拟机的时间</div><div class="line">%idle：空闲时间</div><div class="line"></div><div class="line">重要列有：usr，sys和idle</div></pre></td></tr></table></figure></p>
<h5 id="pidstat-按进程或线程来打印cpu用量"><a href="#pidstat-按进程或线程来打印cpu用量" class="headerlink" title="pidstat 按进程或线程来打印cpu用量"></a>pidstat 按进程或线程来打印cpu用量</h5><p>包括用户态和系统态时间的分解，默认情况下仅输出活动的进程的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">pidstat 1</div><div class="line">05:49:59 PM       PID    %usr %system  %guest    %CPU   CPU  Command</div><div class="line">05:50:00 PM        37    0.00    0.99    0.00    0.99     3  kblockd/3</div><div class="line">05:50:00 PM        60    0.00    0.99    0.00    0.99     0  kswapd0</div><div class="line">05:50:00 PM     18520    0.99    0.99    0.00    1.98     0  pidstat</div><div class="line">05:50:00 PM     18524    0.00   16.83    0.00   16.83     0  tar</div><div class="line">05:50:00 PM     18525   53.47   13.86    0.00   67.33     0  gzip</div><div class="line">-t  打印每个线程的统计信息</div><div class="line">-p ALL  用来打印所有的进程，包括空闲进程</div></pre></td></tr></table></figure></p>
<h5 id="dstat-命令，比较全部的查看系统资源信息"><a href="#dstat-命令，比较全部的查看系统资源信息" class="headerlink" title="dstat 命令，比较全部的查看系统资源信息"></a>dstat 命令，比较全部的查看系统资源信息</h5><p>常用命令： dstat -cdlnmpsy  查看比较全面的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">-c  cpu</div><div class="line">-d disk</div><div class="line">-l  load</div><div class="line">-n net</div><div class="line">-m memory</div><div class="line">-p procs</div><div class="line">-s swap</div><div class="line">-y system</div><div class="line">--output   xxx.csv   生成csv文件，可以通过excel打开</div><div class="line"></div><div class="line">dstat -cdlnmpsy</div><div class="line">---total-cpu-usage---- -dsk/total- ---load-avg--- -net/total- ---procs---&gt;</div><div class="line">usr sys idl wai hiq siq| read  writ| 1m   5m  15m | recv  send|run blk new&gt;</div><div class="line">  2   1  97   0   0   0|  73k  115k|   0 0.01 0.05|   0     0 |  0   0 1.2&gt;</div><div class="line">  0   1  99   0   0   0|   0     0 |   0 0.01 0.05| 146B 1058B|  0   0   0&gt;</div><div class="line">  0   1 100   0   0   0|   0     0 |   0 0.01 0.05| 146B  514B|  0   0   0&gt;</div><div class="line">  1   0  99   0   0   0|   0     0 |   0 0.01 0.05| 146B  514B|  0   0   0&gt;</div><div class="line">  0   0 100   0   0   0|   0     0 |   0 0.01 0.05| 146B  514B|  0   0   0&gt;</div><div class="line">  0   1  99   0   0   0|   0    12k|   0 0.01 0.05| 146B  514B|1.0   0   0&gt;</div><div class="line"></div><div class="line">dstat --top-io --top-bio</div></pre></td></tr></table></figure></p>
<p>PS:相关内容参照《性能之巅-洞悉系统、企业与云计算》第6章-cpu章节</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;CPU使用率:通过测量一段时间内cpu实例忙于执行工作的时间比例获得，以百分比表示&lt;/p&gt;
&lt;p&gt;CPI(每指令周
    
    </summary>
    
      <category term="运维" scheme="https://ttxsgoto.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="CPU" scheme="https://ttxsgoto.github.io/tags/CPU/"/>
    
  </entry>
  
  <entry>
    <title>hexo常用命令</title>
    <link href="https://ttxsgoto.github.io/2017/02/01/hexo/"/>
    <id>https://ttxsgoto.github.io/2017/02/01/hexo/</id>
    <published>2017-02-01T14:38:32.000Z</published>
    <updated>2017-02-07T13:08:42.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">npm install -g hexo # 安装hexo</div><div class="line">hexo init   #初始化hexo目录</div><div class="line">npm install hexo-deployer-git --save 安装git所需的插件</div></pre></td></tr></table></figure>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">hexo clean</div><div class="line">hexo generate # 或者 hexo g 生成静态网页 </div><div class="line">hexo server # 或者 hexo s 启动本地服务</div><div class="line">hexo  deploy    #将本地文件推送到github上</div><div class="line">hexo new &quot;title&quot;    # 新建文章</div><div class="line">hexo new page &quot;pagename&quot;    # 新建页面</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;安装命令&quot;&gt;&lt;a href=&quot;#安装命令&quot; class=&quot;headerlink&quot; title=&quot;安装命令&quot;&gt;&lt;/a&gt;安装命令&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
    
    </summary>
    
      <category term="运维" scheme="https://ttxsgoto.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="hexo" scheme="https://ttxsgoto.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
